<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Block Tetrist - Game Đặt Khối Thông Minh</title>
<style>
  * { box-sizing: border-box; }
  html, body { 
    margin: 0; 
    padding: 0; 
    background: linear-gradient(135deg, #0f1220 0%, #1a1f3a 100%);
    color: #E8EBF7; 
    font-family: 'Segoe UI', system-ui, -apple-system, Roboto, Arial, sans-serif;
    overflow-x: hidden;
    overflow-y: hidden; /* Prevent scrolling on mobile */
  }
  
  #wrap { 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    gap: 8px; /* Reduced gap for mobile */
    padding: 8px; /* Reduced padding for mobile */
    min-height: 100vh;
    max-height: 100vh; /* Force single screen */
  }
  
  .header {
    text-align: center;
    margin-bottom: 8px; /* Reduced margin */
  }
  
  .header h1 {
    margin: 0;
    font-size: 20px; /* Smaller font for mobile */
    font-weight: 700;
    background: linear-gradient(45deg, #5de4c7, #8093ff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  
  .header .subtitle {
    margin: 4px 0 0; /* Reduced margin */
    font-size: 12px; /* Smaller font for mobile */
    opacity: 0.8;
    color: #a6da95;
  }
  
  canvas { 
    background: linear-gradient(145deg, #151a2d, #1c2342);
    border: 2px solid #2a3156; 
    border-radius: 12px; /* Smaller radius for mobile */
    box-shadow: 0 4px 16px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
    position: relative;
    max-width: 100vw; /* Ensure canvas fits mobile width */
    max-height: 60vh; /* Limit height for mobile */
  }
  
  canvas:hover {
    border-color: #3a4376;
    box-shadow: 0 6px 20px rgba(0,0,0,0.4);
  }
  
  .row { 
    display: flex; 
    flex-wrap: wrap; 
    gap: 8px; /* Reduced gap for mobile */
    justify-content: center; 
    align-items: flex-start; 
    max-width: 100vw; /* Full mobile width */
  }
  
  .card { 
    background: linear-gradient(145deg, #161a30, #1a1f3a);
    border: 1px solid #2b335c; 
    padding: 8px 12px; /* Reduced padding for mobile */
    border-radius: 12px; /* Smaller radius for mobile */
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    transition: all 0.3s ease;
    min-width: 140px; /* Smaller min-width for mobile */
    max-width: 45vw; /* Limit width for mobile */
  }
  
  .card:hover {
    border-color: #3a4376;
    transform: translateY(-1px); /* Smaller transform for mobile */
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  }
  
  button { 
    background: linear-gradient(145deg, #2a3156, #3a4376);
    color: #E8EBF7; 
    border: none;
    border-radius: 8px; /* Smaller radius for mobile */
    padding: 8px 12px; /* Smaller padding for mobile */
    cursor: pointer;
    font-size: 12px; /* Smaller font for mobile */
    font-weight: 600;
    transition: all 0.3s ease;
    box-shadow: 0 1px 4px rgba(0,0,0,0.2);
    min-height: 36px; /* Minimum touch target size */
  }
  
  button:hover:not([disabled]) {
    background: linear-gradient(145deg, #3a4376, #4a5386);
    transform: translateY(-1px);
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
  }
  
  button[disabled] { 
    opacity: 0.45; 
    cursor: not-allowed;
    transform: none;
  }
  
  .stat { 
    margin: 2px 6px; /* Reduced margin for mobile */
    font-size: 12px; /* Smaller font for mobile */
    opacity: 0.9; 
  }
  
  .legend { 
    font-size: 11px; /* Smaller font for mobile */
    opacity: 0.9; 
    line-height: 1.4; /* Reduced line height for mobile */
  }
  
  .hl { 
    color: #5de4c7; 
    font-weight: 600; 
  }
  
  .warn { 
    color: #f9c859; 
  }
  
  .bad { 
    color: #f7768e; 
  }
  
  .ok { 
    color: #a6da95; 
  }
  
  .version { 
    position: absolute; 
    top: 8px; /* Reduced top position for mobile */
    right: 8px; /* Reduced right position for mobile */
    font-size: 10px; /* Smaller font for mobile */
    opacity: 0.6;
    background: rgba(26, 26, 26, 0.8);
    padding: 4px 8px; /* Smaller padding for mobile */
    border-radius: 16px;
    backdrop-filter: blur(10px);
  }
  
  .debug { 
    position: absolute; 
    top: 32px; /* Reduced top position for mobile */
    right: 8px; /* Reduced right position for mobile */
    font-size: 9px; /* Smaller font for mobile */
    opacity: 0.8; 
    background: rgba(26, 26, 26, 0.9); 
    padding: 4px 8px; /* Smaller padding for mobile */
    border-radius: 6px;
    backdrop-filter: blur(10px);
    max-width: 150px; /* Smaller max-width for mobile */
  }
  
  .controls-info {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); /* Smaller minmax for mobile */
    gap: 8px; /* Reduced gap for mobile */
    margin-top: 8px; /* Reduced margin for mobile */
  }
  
  .control-group {
    background: rgba(43, 51, 92, 0.3);
    padding: 8px; /* Reduced padding for mobile */
    border-radius: 8px; /* Smaller radius for mobile */
    border-left: 3px solid #5de4c7; /* Smaller border for mobile */
  }
  
  .control-group h3 {
    margin: 0 0 6px 0; /* Reduced margin for mobile */
    font-size: 12px; /* Smaller font for mobile */
    color: #5de4c7;
  }
  
  .key {
    background: #2a3156;
    padding: 2px 4px; /* Smaller padding for mobile */
    border-radius: 4px; /* Smaller radius for mobile */
    font-family: monospace;
    font-weight: bold;
    color: #5de4c7;
    font-size: 10px; /* Smaller font for mobile */
  }
  
  .stats-display {
    display: flex;
    gap: 8px; /* Reduced gap for mobile */
    flex-wrap: wrap;
    justify-content: center;
    margin: 8px 0; /* Reduced margin for mobile */
  }
  
  .stat-item {
    background: rgba(43, 51, 92, 0.3);
    padding: 6px 10px; /* Reduced padding for mobile */
    border-radius: 8px; /* Smaller radius for mobile */
    text-align: center;
    min-width: 60px; /* Smaller min-width for mobile */
  }
  
  .stat-value {
    font-size: 16px; /* Smaller font for mobile */
    font-weight: bold;
    color: #5de4c7;
    margin-bottom: 2px; /* Reduced margin for mobile */
  }
  
  .stat-label {
    font-size: 9px; /* Smaller font for mobile */
    opacity: 0.7;
    text-transform: uppercase;
    letter-spacing: 0.5px; /* Reduced letter spacing for mobile */
  }
  
     /* Game Over Text Overlay */
   .game-over-text {
     position: absolute;
     top: 50%;
     left: 50%;
     transform: translate(-50%, -50%);
     background: linear-gradient(145deg, #161a30, #1a1f3a);
     border: 2px solid #f7768e;
     border-radius: 12px; /* Smaller radius for mobile */
     padding: 16px; /* Reduced padding for mobile */
     text-align: center;
     box-shadow: 0 4px 12px rgba(0,0,0,0.6);
     z-index: 1000;
     min-width: 160px; /* Smaller min-width for mobile */
     max-width: 80vw; /* Limit width for mobile */
   }
   
   .game-over-title {
     font-size: 16px; /* Smaller font for mobile */
     font-weight: bold;
     color: #f7768e;
     margin-bottom: 8px; /* Reduced margin for mobile */
   }
   
   .game-over-button {
     background: linear-gradient(145deg, #5de4c7, #4a5386);
     color: #0f1220;
     font-size: 12px; /* Smaller font for mobile */
     font-weight: bold;
     padding: 6px 12px; /* Smaller padding for mobile */
     border: none;
     border-radius: 6px; /* Smaller radius for mobile */
     cursor: pointer;
     transition: all 0.3s ease;
   }
   
   .game-over-button:hover {
     background: linear-gradient(145deg, #4a5386, #5de4c7);
     transform: translateY(-1px);
     box-shadow: 0 2px 6px rgba(93, 228, 199, 0.3);
   }
  
  /* Combo Text Animation */
  .combo-text {
    position: absolute;
    font-size: 32px; /* Smaller font for mobile */
    font-weight: bold;
    color: #5de4c7;
    text-shadow: 0 0 20px rgba(93, 228, 199, 0.8);
    pointer-events: none;
    z-index: 100;
    animation: comboFadeOut 2s ease-out forwards;
  }
  
  @keyframes comboFadeOut {
    0% {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
    50% {
      opacity: 1;
      transform: scale(1.2) translateY(-20px);
    }
    100% {
      opacity: 0;
      transform: scale(1.5) translateY(-40px);
    }
  }
  
  @media (max-width: 768px) {
    #wrap { 
      padding: 4px; 
      gap: 4px;
    }
    .header h1 { font-size: 18px; }
    .header .subtitle { font-size: 11px; }
    .row { 
      flex-direction: column; 
      align-items: center; 
      gap: 4px;
    }
    .card { 
      min-width: 120px; 
      max-width: 90vw;
      padding: 6px 8px;
    }
    .stats-display { 
      flex-direction: row; 
      align-items: center; 
      gap: 4px;
    }
    .stat-item {
      min-width: 50px;
      padding: 4px 6px;
    }
    .stat-value { font-size: 14px; }
    .stat-label { font-size: 8px; }
    .controls-info {
      grid-template-columns: repeat(2, 1fr);
      gap: 4px;
    }
    .control-group {
      padding: 6px;
    }
    .control-group h3 { font-size: 11px; }
    .control-group p { font-size: 10px; }
    .key { font-size: 9px; }
    .legend { font-size: 10px; }
    .version { 
      top: 4px; 
      right: 4px; 
      font-size: 9px; 
      padding: 3px 6px;
    }
    .debug { 
      top: 24px; 
      right: 4px; 
      font-size: 8px; 
      padding: 3px 6px;
      max-width: 120px;
    }
         .game-over-text { 
       padding: 12px; 
       min-width: 140px; 
       max-width: 85vw;
     }
     .game-over-title { font-size: 14px; }
         .game-over-button { 
      font-size: 11px; 
      padding: 5px 10px;
    }
    /* Mobile-specific canvas sizing */
    canvas {
      max-height: 90vh; /* Even larger on mobile */
      width: 95vw; /* Use most of viewport width */
      height: auto; /* Let height adjust automatically */
    }
  }
  
  /* Game Mode Selector Styles */
  .mode-selector {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(15, 18, 32, 0.9);
    backdrop-filter: blur(10px);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
  }
  
  .mode-selector-content {
    background: linear-gradient(145deg, #161a30, #1a1f3a);
    border: 2px solid #5de4c7;
    border-radius: 16px; /* Smaller radius for mobile */
    padding: 20px; /* Reduced padding for mobile */
    max-width: 90vw; /* Limit width for mobile */
    text-align: center;
    box-shadow: 0 12px 36px rgba(0,0,0,0.5);
  }
  
  .mode-selector h2 {
    margin: 0 0 20px 0; /* Reduced margin for mobile */
    font-size: 20px; /* Smaller font for mobile */
    background: linear-gradient(45deg, #5de4c7, #8093ff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  
  .mode-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 12px; /* Reduced gap for mobile */
    margin-top: 16px; /* Reduced margin for mobile */
  }
  
  .mode-button {
    background: linear-gradient(145deg, #2a3156, #3a4376);
    border: 2px solid #2a3156;
    border-radius: 12px; /* Smaller radius for mobile */
    padding: 12px; /* Reduced padding for mobile */
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: center;
    min-height: 100px; /* Smaller height for mobile */
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }
  
  .mode-button:hover {
    border-color: #5de4c7;
    transform: translateY(-2px); /* Smaller transform for mobile */
    box-shadow: 0 4px 12px rgba(93, 228, 199, 0.3);
  }
  
  .mode-icon {
    font-size: 24px; /* Smaller font for mobile */
    margin-bottom: 6px; /* Reduced margin for mobile */
  }
  
  .mode-title {
    font-size: 14px; /* Smaller font for mobile */
    font-weight: bold;
    color: #5de4c7;
    margin-bottom: 4px; /* Reduced margin for mobile */
  }
  
  .mode-desc {
    font-size: 10px; /* Smaller font for mobile */
    opacity: 0.8;
    margin-bottom: 8px; /* Reduced margin for mobile */
    line-height: 1.3; /* Reduced line height for mobile */
  }
  
  .mode-highscore {
    font-size: 9px; /* Smaller font for mobile */
    color: #a6da95;
    font-weight: 600;
  }
  
     /* High Score Display */
   .high-score-display {
     position: absolute;
     top: 8px; /* Reduced top position for mobile */
     left: 8px; /* Reduced left position for mobile */
     background: rgba(26, 26, 26, 0.9);
     padding: 8px; /* Reduced padding for mobile */
     border-radius: 8px; /* Smaller radius for mobile */
     backdrop-filter: blur(10px);
     border-left: 3px solid #5de4c7; /* Smaller border for mobile */
     min-width: 120px; /* Smaller min-width for mobile */
     max-width: 35vw; /* Limit width for mobile */
   }
  
  .high-score-display h3 {
    margin: 0 0 6px 0; /* Reduced margin for mobile */
    font-size: 11px; /* Smaller font for mobile */
    color: #5de4c7;
    text-align: center;
  }
  
  .high-score-item {
    display: flex;
    justify-content: space-between;
    margin: 3px 0; /* Reduced margin for mobile */
    font-size: 9px; /* Smaller font for mobile */
  }
  
  .high-score-label {
    color: #8b90a7;
  }
  
  .high-score-value {
    color: #a6da95;
    font-weight: bold;
  }
  
  /* Mobile Touch Controls */
  .mobile-controls {
    display: flex;
    gap: 8px;
    justify-content: center;
    margin: 8px 0;
    flex-wrap: wrap;
  }
  
  .control-btn {
    background: linear-gradient(145deg, #2a3156, #3a4376);
    border: 2px solid #5de4c7;
    border-radius: 8px;
    padding: 8px 12px;
    color: #E8EBF7;
    font-size: 12px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    min-width: 60px;
    min-height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .control-btn:hover {
    background: linear-gradient(145deg, #3a4376, #4a5386);
    transform: translateY(-1px);
  }
  
  .control-btn:active {
    transform: translateY(0);
  }
  
  .control-btn[disabled] {
    opacity: 0.5;
    cursor: not-allowed;
    border-color: #2a3156;
  }
  
  /* Drag and Drop Styles */
  .piece-dragging {
    opacity: 0.7;
    transform: scale(1.1);
    transition: all 0.2s ease;
  }
  
  .board-drop-zone {
    position: relative;
  }
  
  .drop-preview {
    position: absolute;
    pointer-events: none;
    z-index: 50;
    opacity: 0.6;
  }
  
  .drag-active {
    cursor: grabbing !important;
  }
  
  .pool-slot-draggable {
    cursor: grab;
    transition: all 0.2s ease;
  }
  
  .pool-slot-draggable:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(93, 228, 199, 0.3);
  }
  
  @media (max-width: 768px) {
    .mode-grid {
      grid-template-columns: 1fr;
      gap: 8px;
    }
    
    .mode-selector-content {
      padding: 16px;
      margin: 16px;
      max-width: 95vw;
    }
    
    .mode-button {
      min-height: 80px;
      padding: 10px;
    }
    
    .mode-icon { font-size: 20px; }
    .mode-title { font-size: 12px; }
    .mode-desc { font-size: 9px; }
    .mode-highscore { font-size: 8px; }
    
         .high-score-display {
       position: relative;
       top: auto;
       left: auto;
       margin: 8px auto;
       max-width: 90vw;
       min-width: 200px;
     }
     
     .mobile-controls {
       gap: 6px;
       margin: 6px 0;
     }
     
     .control-btn {
       min-width: 50px;
       min-height: 36px;
       font-size: 11px;
       padding: 6px 8px;
     }
  }
</style>
</head>
<body>
<div id="wrap">
     <div class="version">v1.9.19-critical-fix</div>
  <div class="debug" id="debug"></div>
  
  <!-- High Score Display -->
  <div class="high-score-display">
    <h3>🏆 High Scores</h3>
    <div class="high-score-item">
      <span class="high-score-label">Basic:</span>
      <span class="high-score-value" id="basic-highscore-display">0</span>
    </div>
    <div class="high-score-item">
      <span class="high-score-label">Blocker:</span>
      <span class="high-score-value" id="blocker-highscore-display">0</span>
    </div>
    <div class="high-score-item">
      <span class="high-score-label">Multiplier:</span>
      <span class="high-score-value" id="multiplier-highscore-display">0</span>
    </div>
    <div class="high-score-item">
      <span class="high-score-label">Blast:</span>
      <span class="high-score-value" id="blast-highscore-display">0</span>
    </div>
  </div>
  
  <div class="header">
    <h1>Block Tetrist</h1>
    <div class="subtitle">Game Đặt Khối Thông Minh - Bàn 8×8</div>
  </div>
  
    <canvas id="game" width="720" height="900"></canvas>
  
  <!-- Game Mode Selector Popup -->
  <div id="mode-selector" class="mode-selector">
    <div class="mode-selector-content">
      <h2>🎮 Chọn Chế Độ Chơi</h2>
      <div class="mode-grid">
        <button class="mode-button" data-mode="basic">
          <div class="mode-icon">🎯</div>
          <div class="mode-title">Basic Mode</div>
          <div class="mode-desc">Chain multiplier cơ bản</div>
          <div class="mode-highscore">High Score: <span id="basic-highscore">0</span></div>
        </button>
        <button class="mode-button" data-mode="blocker">
          <div class="mode-icon">🛡️</div>
          <div class="mode-title">Blocker Mode</div>
          <div class="mode-desc">Durable pieces + Precision bonus</div>
          <div class="mode-highscore">High Score: <span id="blocker-highscore">0</span></div>
        </button>
        <button class="mode-button" data-mode="multiplier">
          <div class="mode-icon">⭐</div>
          <div class="mode-title">Multiplier Mode</div>
          <div class="mode-desc">Bonus points system</div>
          <div class="mode-highscore">High Score: <span id="multiplier-highscore">0</span></div>
        </button>
        <button class="mode-button" data-mode="blast">
          <div class="mode-icon">💣</div>
          <div class="mode-title">Blast Mode</div>
          <div class="mode-desc">Bomb explosion system</div>
          <div class="mode-highscore">High Score: <span id="blast-highscore">0</span></div>
        </button>
      </div>
    </div>
  </div>
  
  <!-- Game Over Text Overlay -->
   <div id="game-over-overlay" class="game-over-text" style="display: none;">
     <div class="game-over-title">Thua Rồi!</div>
     <div class="game-over-stats">
       <div class="final-score">Điểm: <span id="final-score">0</span></div>
       <div class="current-mode">Mode: <span id="current-mode-display">Basic</span></div>
     </div>
     <button class="game-over-button" onclick="resetGame()">Chơi Lại</button>
     <div class="other-modes">
       <div class="other-modes-title">Chơi Mode Khác:</div>
       <div class="other-modes-buttons">
         <button class="other-mode-btn" data-mode="basic">Basic</button>
         <button class="other-mode-btn" data-mode="blocker">Blocker</button>
         <button class="other-mode-btn" data-mode="multiplier">Multiplier</button>
         <button class="other-mode-btn" data-mode="blast">Blast</button>
       </div>
     </div>
   </div>
  
  <div class="stats-display">
    <div class="stat-item">
      <div class="stat-value" id="score-display">0</div>
      <div class="stat-label">Điểm</div>
    </div>
    <div class="stat-item">
      <div class="stat-value" id="turn-display">0</div>
      <div class="stat-label">Lượt</div>
    </div>
    <div class="stat-item">
      <div class="stat-value" id="combo-display">1.0×</div>
      <div class="stat-label">Combo</div>
    </div>
    <div class="stat-item">
      <div class="stat-value" id="fr-display">0%</div>
      <div class="stat-label">Fill Rate</div>
    </div>
  </div>
  
  <!-- Mobile Touch Controls -->
  <div class="mobile-controls">
    <button class="control-btn" id="hold-btn" disabled>Hold</button>
    <button class="control-btn" id="swap1-btn" disabled>Swap 1</button>
    <button class="control-btn" id="swap2-btn" disabled>Swap 2</button>
    <button class="control-btn" id="swap3-btn" disabled>Swap 3</button>
  </div>
  
  <div class="row">
    <div class="card legend">
      <h3>🎮 Cách Chơi</h3>
      <p><b>Chọn khối</b> từ pool bên dưới, sau đó <b>click lên ô</b> trên bàn để đặt. <span class="hl">Chuột phải</span> để bỏ chọn.</p>
      <p><b>🖱️ Drag & Drop:</b> Kéo khối từ pool lên bàn chơi để đặt nhanh hơn!</p>
      <p><span class="hl">Hold (H)</span>: Lưu 1 khối (CD 3 lượt)</p>
      <p><span class="hl">Swap (1/2/3)</span>: Đổi khối sang khối cứu nạn (CD 9 lượt)</p>
             <p><span class="hl">Ô đỏ có số</span>: Piece có độ bền, cần xóa đủ số lần để biến mất</p>
             <p><span class="hl">Ô bonus x2-x7</span>: Nhân điểm khi clear line chứa ô bonus</p>
    </div>
    
    <div class="card legend">
      <h3>🏆 Hệ Thống Điểm</h3>
      <p><b>Chain</b>: Clear liên tiếp tăng multiplier (≤1.5×)</p>
      <p><b>Precision</b>: Clear ≥2 line nhân điểm (1.2× / 1.5×)</p>
      <p><b>Combo</b>: Tích lũy theo thời gian</p>
      <p><b>Bonus Pieces</b>: Ô x2-x7 nhân điểm khi clear line</p>
      <p><b>Xoay khối</b>: 32 loại khối với 4 hướng xoay khác nhau</p>
    </div>
    
    <div class="card legend" id="msg"></div>
  </div>
  
  <div class="controls-info">
    <div class="control-group">
      <h3>⌨️ Điều Khiển</h3>
      <p><span class="key">H</span> - Hold khối đang chọn</p>
      <p><span class="key">1</span> - Swap khối slot 1</p>
      <p><span class="key">2</span> - Swap khối slot 2</p>
      <p><span class="key">3</span> - Swap khối slot 3</p>
      <p><span class="key">Chuột phải</span> - Bỏ chọn</p>
    </div>
    
    <div class="control-group">
      <h3>🎯 Mục Tiêu</h3>
      <p>Đặt khối để tạo thành hàng/cột hoàn chỉnh</p>
      <p>Clear càng nhiều line càng tốt</p>
      <p>Duy trì combo để tăng điểm</p>
      <p>Quản lý Fill Rate thông minh</p>
             <p>Clear các ô có độ bền (màu đỏ) để tăng điểm</p>
    </div>
    
    <div class="control-group">
      <h3>🎁 Hệ Thống Bonus</h3>
      <p>Ô bonus x2-x7 xuất hiện sau clear line (30% chance)</p>
      <p>Clear line chứa ô bonus → nhân điểm tương ứng</p>
      <p>Nhiều ô bonus cùng lúc → nhân dồn (x2 × x5 = x10)</p>
      <p>Ô bonus tự biến mất sau 2-4 lượt</p>
    </div>
  </div>
</div>

<script>
(function(){
  const W = 720, H = 900;
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // Layout
  const BOARD_SIZE = 8;
  const CELL = isMobile ? 80 : 60; // Larger cells on mobile
  const BOARD_X = (W - CELL*BOARD_SIZE)/2; // center
  const BOARD_Y = isMobile ? 60 : 40; // More space from top on mobile
  const POOL_Y = isMobile ? 580 : 620; // Adjust pool position for mobile
  
  // Mobile detection
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

  // Tuning
  const scoring = {
    cell: 1,
    line: 10,
    precisionTwo: 1.2,
    precisionThree: 1.5,
    comboSteps: [1.0, 1.1, 1.3, 1.5],
    comboCap: 1.5
  };
  const holdCfg = { cdTurns: 3 };
  const swapCfg = { cdTurns: 9, rescueSet: ["I2","I2_90","I3","I3_90","L3","L3_90","L3_180","L3_270"] };
  const frWindow = { low: 0.30, high: 0.70 };
  const biasCfg = { base: 0.05, alpha: 0.20, betaJustDead: 0.10, cap: 0.25 };
  const guardrail = { windowRefills: 50, maxDead: 1 };

  // Game Mode System
  let currentGameMode = 'basic'; // 'basic', 'blocker', 'multiplier', 'blast'
  let gameStarted = false;
  
  // High Scores for each mode
  let highScores = {
    basic: parseInt(localStorage.getItem('blockTetristHighScore_basic')) || 0,
    blocker: parseInt(localStorage.getItem('blockTetristHighScore_blocker')) || 0,
    multiplier: parseInt(localStorage.getItem('blockTetristHighScore_multiplier')) || 0,
    blast: parseInt(localStorage.getItem('blockTetristHighScore_blast')) || 0
  };
  
  // State
  let grid = new Array(BOARD_SIZE).fill(0).map(()=>new Array(BOARD_SIZE).fill(0));
  let pool = [null, null, null]; // Initialize with null slots
  let score = 0;
  let comboLevel = 0;
  let selected = { from:"pool", index:-1, dx:0, dy:0 };
  let hold = { piece:null, cd:0 };
  let swapCD = 0;
  let recentDead = [];
  let justDead = false;
  let turn = 0;
  let highScore = highScores[currentGameMode]; // Current mode's high score
  let gameOver = false;
  let durablePieces = []; // Pieces with durability instead of blocked cells
  let comboTexts = [];
  let comboStreak = 0; // Combo streak counter for consecutive line clears
  let bonusPieces = []; // Bonus pieces with multipliers
  let bonusTexts = []; // Bonus score texts
  let bombPieces = []; // Bomb pieces that explode when lines are cleared
  let bombTexts = []; // Bomb explosion score texts
  let bombSpawned = false; // Track if bomb has been spawned this game
  
  // Drag & Drop variables
  let isDragging = false;
  let draggedPiece = null;
  let dragStartPos = { x: 0, y: 0 };
  let dragOffset = { x: 0, y: 0 };
  let dropPreview = null;

  // 65 pieces with rotations (v1.9.15) - Refactored to use string-based piece definitions with decodePiece function
  // Format: 'x' = filled cell (1), 'o' = empty cell (0)
  // Multi-line format for better readability
  function decodePiece(...rows) {
    const coords = [];
    for (let r = 0; r < rows.length; r++) {
      const row = rows[r];
      for (let c = 0; c < row.length; c++) {
        if (row[c] === 'x') {
          coords.push([r, c]);
        }
        // 'o' represents empty cells (0), so we skip them
      }
    }
    return coords;
  }
  
  const PIECES = {
    // 1x1 - 1 direction (symmetric)
    "1x1": decodePiece("x"),
    
    // I2, I3, I4, S4, Z4 - 2 directions (0°, 90°)
    "I2": decodePiece(
      "x",
      "x"
    ), 
    "I2_90": decodePiece("xx"),
    "I3": decodePiece(
      "x",
      "x",
      "x"
    ), 
    "I3_90": decodePiece("xxx"),
    "I4": decodePiece(
      "x",
      "x",
      "x",
      "x"
    ), 
    "I4_90": decodePiece("xxxx"),
    "S4": decodePiece(
      "oxx",
      "xxo"
    ), 
    "S4_90": decodePiece(
      "xo",
      "xx",
      "ox"
    ),
    "Z4": decodePiece(
      "xxo",
      "oxx"
    ), 
    "Z4_90": decodePiece(
      "ox",
      "xx",
      "xo"
    ),
    
    // 2x2, O3 - 1 direction (symmetric)
    "2x2": decodePiece(
      "xx",
      "xx"
    ),
    "O3": decodePiece(
      "xxx",
      "xxx",
      "xxx"
    ),
    
    // L3, L4, T4 - 4 directions (0°, 90°, 180°, 270°)
    "L3": decodePiece(
      "xo",
      "xx"
    ), 
    "L3_90": decodePiece(
      "ox",
      "xx"
    ), 
    "L3_180": decodePiece(
      "xx",
      "ox"
    ), 
    "L3_270": decodePiece(
      "xx",
      "xo"
    ),
    "L4": decodePiece(
      "xo",
      "xo",
      "xx"
    ), 
    "L4_90": decodePiece(
      "xxx",
      "xoo"
    ), 
    "L4_180": decodePiece(
      "xx",
      "ox",
      "ox"
    ), 
    "L4_270": decodePiece(
      "oox",
      "xxx"
    ),
    "L4R": decodePiece(
      "ox",
      "ox",
      "xx"
    ), 
    "L4_90": decodePiece(
      "xoo",
      "xxx"
    ), 
    "L4_180": decodePiece(
      "xx",
      "xo",
      "xo"
    ), 
    "L4_270": decodePiece(
      "xxx",
      "oox"
    ),
    "T4": decodePiece(
      "xxx",
      "oxo"
    ), 
    "T4_90": decodePiece(
      "ox",
      "xx",
      "ox"
    ), 
    "T4_180": decodePiece(
      "oxo",
      "xxx"
    ), 
    "T4_270": decodePiece(
      "xo",
      "xx",
      "xo"
    ),
    
    "T5": decodePiece(
      "xxx",
      "oxo",
      "oxo"
    ), 
    "T5_90": decodePiece(
      "oox",
      "xxx",
      "oox"
    ), 
    "T5_180": decodePiece(
      "oxo",
      "oxo",
      "xxx"
    ), 
    "T5_270": decodePiece(
      "xoo",
      "xxx",
      "xoo"
    ),
    "C5": decodePiece(
      "xxx",
      "xoo",
      "xoo"
    ), 
    "C5_90": decodePiece(
      "oox",
      "oox",
      "xxx"
    ), 
    "C5_180": decodePiece(
      "xoo",
      "xoo",
      "xxx"
    ), 
    "C5_270": decodePiece(
      "xxx",
      "oox",
      "oox"
    ),

    // Shape 1: 2x3 rectangle
    "R2x3": decodePiece(
      "xxx",
      "xxx"
    ), 
    "R2x3_90": decodePiece(
      "xx",
      "xx",
      "xx"
    ), 

    
    // Shape 1.5: I5 - 5 ô thẳng (2 hướng)
    "I5": decodePiece(
      "x",
      "x",
      "x",
      "x",
      "x"
    ), 
    "I5_90": decodePiece("xxxxx"),
    

    
    // Shape 5.5: U5 - U shape 5 ô (4 hướng rotation)
    "U5": decodePiece(
      "xox",
      "xxx"
    ),           // 0°: U shape ngang
    "U5_90": decodePiece(
      "xx",
      "xo",
      "xx"
    ),         // 90°: U shape dọc
    "U5_180": decodePiece(
      "xxx",
      "xox"
    ),        // 180°: U shape ngang đảo
    "U5_270": decodePiece(
      "xx",
      "ox",
      "xx"
    ),        // 270°: U shape dọc đảo

    // Shape U7 - U shape 7 ô
    "U7": decodePiece(
      "xox",
      "xox",
      "xxx"
    ),           // 0°: U shape ngang
    "U7_90": decodePiece(
      "xxx",
      "xoo",
      "xxx"
    ),         // 90°: U shape dọc
    "U7_180": decodePiece(
      "xxx",
      "xox",
      "xox"
    ),        // 180°: U shape ngang đảo
    "U7_270": decodePiece(
      "xxx",
      "oox",
      "xxx"
    ),        // 270°: U shape dọc đảo
     
    // Shape 6: 2x2 + right extension
    "R2x2R": decodePiece(
      "xx",
      "xx",
      "ox"
    ), 
    "R2x2R_90": decodePiece(
      "xxx",
      "xxo"
    ), 
    "R2x2R_180": decodePiece(
      "xo",
      "xx",
      "xx"
    ), 
    "R2x2R_270": decodePiece(
      "oxx",
      "xxx"
    ),
     

    // Shape 7: 

    "V3": decodePiece(
      "xox",
      "oxo"
    ), 
    "V3_90": decodePiece(
      "xo",
      "ox",
      "xo"
    ), 
    "V3_180": decodePiece(
      "ox",
      "xo",
      "ox"
    ), 
    "V3_270": decodePiece(
      "oxo",
      "xox"
    ),
     
    // Shape 9: Cross shape (1 direction - symmetric)
    "Cross": decodePiece(
      "oxo",
      "xxx",
      "oxo"
    ),

    // Shape 10: Cross shape 1
    "Cross_1": decodePiece(
      "xox",
      "oxo",
      "xox"
    ),

     
    // Shape 12: Vertical line + right extension
    "L5": decodePiece(
      "xo",
      "xo",
      "xo",
      "xx"
    ), 
    "L5_90": decodePiece(
      "xxxx",
      "xooo"
    ), 
    "L5_180": decodePiece(
      "xx",
      "ox",
      "ox",
      "ox"
    ), 
    "L5_270": decodePiece(
      "ooox",
      "xxxx"
    ),
    "L5R": decodePiece(
      "ox",
      "ox",
      "ox",
      "xx"
    ), 
    "L5_90": decodePiece(
      "xooo",
      "xxxx"
    ), 
    "L5_180": decodePiece(
      "xx",
      "xo",
      "xo",
      "xo"
    ), 
    "L5_270": decodePiece(
      "xxxx",
      "ooox"
    ),

    // Shape 12: Vertical line + right extension
    "L5T": decodePiece(
      "xo",
      "xo",
      "xx",
      "xo"
    ), 
    "L5T_90": decodePiece(
      "xxxx",
      "oxoo"
    ), 
    "L5T_180": decodePiece(
      "ox",
      "xx",
      "ox",
      "ox"
    ), 

    "L5t_270": decodePiece(
      "ooxo",
      "xxxx"
  ),

    // Shape 13: Diagonal 2 ô (4 hướng rotation)
    "X2": decodePiece(
      "xo",
      "ox"
    ),           // 0°: chéo từ trái-trên xuống phải-dưới
    "X2_90": decodePiece(
      "ox",
      "xo"
    ),         // 90°: chéo từ phải-trên xuống trái-dưới
    "X3": decodePiece(
      "xoo",
      "oxo",
      "oox"
    ),        // 180°: giống 0° (đối xứng)
    "X3_90": decodePiece(
      "oox",
      "oxo",
      "xoo"
    ),         // 270°: giống 90° (đối xứng)
  };
  
     // Piece colors for each rotation
   const PIECE_COLORS = {
     // Base pieces
     "1x1": "#ff6b6b", "2x2": "#5de4c7", "O3": "#ffa94d",
     
     // I pieces
     "I2": "#51cf66", "I2_90": "#51cf66",
     "I3": "#ffd43b", "I3_90": "#ffd43b",
     "I4": "#f783ac", "I4_90": "#f783ac",
     "I5": "#ff6b9b", "I5_90": "#ff6b9b",
     
     // S and Z pieces
     "S4": "#40c057", "S4_90": "#40c057",
     "Z4": "#e64980", "Z4_90": "#e64980",
     
     // L pieces
     "L3": "#4c6ef5", "L3_90": "#4c6ef5", "L3_180": "#4c6ef5", "L3_270": "#4c6ef5",
     "L4": "#ae3ec9", "L4_90": "#ae3ec9", "L4_180": "#ae3ec9", "L4_270": "#ae3ec9",
     "L4R": "#ae3ec9", "L4_90": "#ae3ec9", "L4_180": "#ae3ec9", "L4_270": "#ae3ec9",
     
     // T pieces
     "T4": "#ff6b6b", "T4_90": "#ff6b6b", "T4_180": "#ff6b6b", "T4_270": "#ff6b6b",
     "T5": "#ff6b6b", "T5_90": "#ff6b6b", "T5_180": "#ff6b6b", "T5_270": "#ff6b6b",
     
     // C pieces
     "C5": "#ff6b6b", "C5_90": "#ff6b6b", "C5_180": "#ff6b6b", "C5_270": "#ff6b6b",
     
     // Rectangle pieces
     "R2x3": "#ff8787", "R2x3_90": "#ff8787",
     
     // U pieces
     "U5": "#ff6b35", "U5_90": "#ff6b35", "U5_180": "#ff6b35", "U5_270": "#ff6b35",
     "U7": "#ff6b35", "U7_90": "#ff6b35", "U7_180": "#ff6b35", "U7_270": "#ff6b35",
     
     // R2x2R pieces
     "R2x2R": "#4caf50", "R2x2R_90": "#4caf50", "R2x2R_180": "#4caf50", "R2x2R_270": "#4caf50",
     
     // V pieces
     "V3": "#ff6b6b", "V3_90": "#ff6b6b", "V3_180": "#ff6b6b", "V3_270": "#ff6b6b",
     
     // Cross pieces
     "Cross": "#9c27b0", "Cross_1": "#9c27b0",
     
     // L5 pieces
     "L5": "#4c6ef5", "L5_90": "#4c6ef5", "L5_180": "#4c6ef5", "L5_270": "#4c6ef5",
     "L5R": "#4c6ef5", "L5_90": "#4c6ef5", "L5_180": "#4c6ef5", "L5_270": "#4c6ef5",
     "L5T": "#4c6ef5", "L5T_90": "#4c6ef5", "L5T_180": "#4c6ef5", "L5t_270": "#4c6ef5",
     
     // X pieces
     "X2": "#ff6b6b", "X2_90": "#ff6b6b",
     "X3": "#ff6b6b", "X3_90": "#ff6b6b"
   };
  
     // Base weights for all pieces
   const BASE_WEIGHTS = {
     // Base pieces
     "1x1": 0.02, "2x2": 0.07, "O3": 0.05,
     
     // I pieces
     "I2": 0.05, "I2_90": 0.05,
     "I3": 0.05, "I3_90": 0.05,
     "I4": 0.07, "I4_90": 0.07,
     "I5": 0.07, "I5_90": 0.07,
     
     // S and Z pieces
     "S4": 0.06, "S4_90": 0.06,
     "Z4": 0.06, "Z4_90": 0.06,
     
     // L pieces
     "L3": 0.06, "L3_90": 0.06, "L3_180": 0.06, "L3_270": 0.06,
     "L4": 0.07, "L4_90": 0.07, "L4_180": 0.07, "L4_270": 0.07,
     "L4R": 0.07, "L4_90": 0.07, "L4_180": 0.07, "L4_270": 0.07,
     
     // T pieces
     "T4": 0.06, "T4_90": 0.06, "T4_180": 0.06, "T4_270": 0.06,
     "T5": 0.06, "T5_90": 0.06, "T5_180": 0.06, "T5_270": 0.06,
     
     // C pieces
     "C5": 0.06, "C5_90": 0.06, "C5_180": 0.06, "C5_270": 0.06,
     
     // Rectangle pieces
     "R2x3": 0.06, "R2x3_90": 0.06,
     
     // U pieces
     "U5": 0.06, "U5_90": 0.06, "U5_180": 0.06, "U5_270": 0.06,
     "U7": 0.06, "U7_90": 0.06, "U7_180": 0.06, "U7_270": 0.06,
     
     // R2x2R pieces
     "R2x2R": 0.06, "R2x2R_90": 0.06, "R2x2R_180": 0.06, "R2x2R_270": 0.06,
     
     // V pieces
     "V3": 0.06, "V3_90": 0.06, "V3_180": 0.06, "V3_270": 0.06,
     
     // Cross pieces
     "Cross": 0.06, "Cross_1": 0.06,
     
     // L5 pieces
     "L5": 0.06, "L5_90": 0.06, "L5_180": 0.06, "L5_270": 0.06,
     "L5R": 0.06, "L5_90": 0.06, "L5_180": 0.06, "L5_270": 0.06,
     "L5T": 0.06, "L5T_90": 0.06, "L5T_180": 0.06, "L5t_270": 0.06,
     
     // X pieces
     "X2": 0.06, "X2_90": 0.06,
     "X3": 0.06, "X3_90": 0.06
   };

  function rnd(){ return Math.random(); }
  function clone(obj){ return JSON.parse(JSON.stringify(obj)); }
  function msg(t){ document.getElementById('msg').innerHTML = t; }
  function debug(t){ document.getElementById('debug').innerHTML = t; }
  
  // Game Mode Management Functions
  function selectGameMode(mode) {
    currentGameMode = mode;
    highScore = highScores[mode];
    gameStarted = true;
    
    // Hide mode selector
    document.getElementById('mode-selector').style.display = 'none';
    
    // Reset game for new mode
    resetGame();
    
    // Update high score display
    updateHighScoreDisplay();
    
    console.log(`Game mode selected: ${mode}`);
  }
  
  function updateHighScoreDisplay() {
    // Update mode selector high scores
    document.getElementById('basic-highscore').textContent = highScores.basic;
    document.getElementById('blocker-highscore').textContent = highScores.blocker;
    document.getElementById('multiplier-highscore').textContent = highScores.multiplier;
    document.getElementById('blast-highscore').textContent = highScores.blast;
    
    // Update right panel high scores
    document.getElementById('basic-highscore-display').textContent = highScores.basic;
    document.getElementById('blocker-highscore-display').textContent = highScores.blocker;
    document.getElementById('multiplier-highscore-display').textContent = highScores.multiplier;
    document.getElementById('blast-highscore-display').textContent = highScores.blast;
  }
  
  function saveHighScore(mode, score) {
    if (score > highScores[mode]) {
      highScores[mode] = score;
      localStorage.setItem(`blockTetristHighScore_${mode}`, score.toString());
      console.log(`New high score for ${mode} mode: ${score}`);
      return true;
    }
    return false;
  }
  
  function showModeSelector() {
    document.getElementById('mode-selector').style.display = 'flex';
    gameStarted = false;
    
    // Show helpful message
    msg('🎮 Chọn chế độ chơi để bắt đầu!');
  }
  
  function getModeDisplayName(mode) {
    const modeNames = {
      'basic': 'Basic Mode',
      'blocker': 'Blocker Mode', 
      'multiplier': 'Multiplier Mode',
      'blast': 'Blast Mode'
    };
    return modeNames[mode] || mode;
  }

  function updateStats() {
    document.getElementById('score-display').textContent = score;
    document.getElementById('turn-display').textContent = turn;
    document.getElementById('combo-display').textContent = Math.min(scoring.comboSteps[comboLevel], scoring.comboCap).toFixed(1) + '×';
    document.getElementById('fr-display').textContent = Math.round(getFillRate() * 100) + '%';
    
    // Update high score for current mode
    if (score > highScore) {
      highScore = score;
      saveHighScore(currentGameMode, score);
    }
    
    // Update mobile control buttons
    updateMobileControls();
  }
  
  function updateMobileControls() {
    if (!isMobile) return;
    
    // Update Hold button
    const holdBtn = document.getElementById('hold-btn');
    holdBtn.disabled = !hold.piece && (hold.cd > 0 || selected.index < 0);
    holdBtn.textContent = hold.cd > 0 ? `Hold (${hold.cd})` : 'Hold';
    
    // Update Swap buttons
    const swap1Btn = document.getElementById('swap1-btn');
    const swap2Btn = document.getElementById('swap2-btn');
    const swap3Btn = document.getElementById('swap3-btn');
    
    swap1Btn.disabled = swapCD > 0;
    swap2Btn.disabled = swapCD > 0;
    swap3Btn.disabled = swapCD > 0;
    
    swap1Btn.textContent = swapCD > 0 ? `Swap 1 (${swapCD})` : 'Swap 1';
    swap2Btn.textContent = swapCD > 0 ? `Swap 2 (${swapCD})` : 'Swap 2';
    swap3Btn.textContent = swapCD > 0 ? `Swap 3 (${swapCD})` : 'Swap 3';
  }
  
  function checkGameOver() {
    // Check if there are any empty cells on the board
    let hasEmptyCells = false;
    for(let r = 0; r < BOARD_SIZE; r++) {
      for(let c = 0; c < BOARD_SIZE; c++) {
        if(!grid[r][c] && !isDurablePiece(r, c)) {
          hasEmptyCells = true;
          break;
        }
      }
      if(hasEmptyCells) break;
    }
    
    // If no empty cells, game is over (victory condition)
    if(!hasEmptyCells) return true;
    
    // Check if any piece in pool can be placed anywhere
    for(let i = 0; i < pool.length; i++) {
      if(pool[i] !== null) {
        // If this piece can be placed anywhere, game continues
        if(validPlacementsAny(pool[i])) return false;
      }
    }
    
    // If pool is empty, game is NOT over - just need to refill
    if(pool.every(p => p === null)) return false;
    
    // If we reach here, pool has pieces but none can be placed
    // Game over - player cannot place any remaining pieces
    return true;
  }
  
  function resetGame() {
    grid = new Array(BOARD_SIZE).fill(0).map(()=>new Array(BOARD_SIZE).fill(0));
    pool = [null, null, null];
    score = 0;
    comboLevel = 0;
    selected = { from:"pool", index:-1, dx:0, dy:0 };
    hold = { piece:null, cd:0 };
    swapCD = 0;
    recentDead = [];
    justDead = false;
    turn = 0;
    gameOver = false;
    comboTexts = [];
    comboStreak = 0;
    bonusPieces = [];
    bonusTexts = [];
    bombPieces = [];
    bombTexts = [];
    bombSpawned = false;
    
    // Reset drag & drop
    isDragging = false;
    draggedPiece = null;
    dropPreview = null;
    
    // Generate features based on game mode
    if (currentGameMode === 'blocker') {
      generateDurablePieces();
    }
    
    refillPool();
    render();
  }
  
  // Make resetGame globally accessible
  window.resetGame = resetGame;
  
  function addComboText(text, x, y) {
    const comboText = {
      text: text,
      x: x,
      y: y,
      startTime: Date.now(),
      id: Math.random()
    };
    comboTexts.push(comboText);
    
    // Remove after animation
    setTimeout(() => {
      comboTexts = comboTexts.filter(ct => ct.id !== comboText.id);
    }, 2000);
  }
  
  function drawComboTexts() {
    const currentTime = Date.now();
    comboTexts.forEach(ct => {
      let elapsed = currentTime - ct.startTime;
      let progress = elapsed / 2000; // 2 seconds total
      
      if(progress < 1) {
        ctx.save();
        ctx.globalAlpha = 1 - progress;
        ctx.font = "48px system-ui";
        ctx.fillStyle = "#5de4c7";
        ctx.textAlign = "center";
        ctx.fillText(ct.text, ct.x, ct.y - progress * 40);
        ctx.restore();
      }
    });
  }
  
  // Drag & Drop Functions
  function startDrag(piece, startX, startY) {
    if (!piece) return;
    
    // Clear any existing selection
    selected.index = -1;
    
    isDragging = true;
    draggedPiece = piece;
    dragStartPos = { x: startX, y: startY };
    dragOffset = { x: startX, y: startY };
    
    // Update cursor and visual feedback
    canvas.classList.add('drag-active');
    
    // Don't remove piece from pool immediately - keep it there until drop
    // This prevents the piece from disappearing during drag
    
    render();
  }
  
  function updateDrag(currentX, currentY) {
    if (!isDragging || !draggedPiece) return;
    
    dragOffset = { x: currentX, y: currentY };
    
    // Check if over board
    let boardPos = gridAt(currentX, currentY);
    if (boardPos && canPlace(draggedPiece, boardPos.r, boardPos.c)) {
      dropPreview = { piece: draggedPiece, r: boardPos.r, c: boardPos.c };
    } else {
      dropPreview = null;
    }
    
    render();
  }
  
  function endDrag() {
    if (!isDragging || !draggedPiece) return;
    
    if (dropPreview) {
      // Place piece on board using helper function
      placePieceOnBoard(draggedPiece, dropPreview.r, dropPreview.c);
    } else {
      // Return piece to pool if drop failed
      let emptySlot = pool.findIndex(p => p === null);
      if (emptySlot !== -1) {
        pool[emptySlot] = draggedPiece;
      } else {
        // If no empty slot, find the original slot
        let originalSlot = pool.findIndex(p => p === draggedPiece);
        if (originalSlot === -1) {
          // If piece not found in pool, add it back to first available slot
          pool[0] = draggedPiece;
        }
      }
    }
    
    // Reset drag state
    isDragging = false;
    draggedPiece = null;
    dropPreview = null;
    
    // Remove cursor class
    canvas.classList.remove('drag-active');
    
    render();
  }

  function normalize(weights){
    let s=0; for (const k in weights) s+=weights[k];
    const out={}; for (const k in weights) out[k]=weights[k]/s;
    return out;
  }
  function applyBias(base, keys, factor){
    const out = {...base};
    for(const k of keys){ if(out[k]!=null) out[k]*=(1+factor); }
    return normalize(out);
  }
  function sampleOne(weights){
    const r = rnd(); let acc=0, last=null;
    for(const k in weights){ acc+=weights[k]; last=k; if(r<=acc) return makePiece(k); }
    return makePiece(last);
  }
  function sampleThree(weights){ return [sampleOne(weights), sampleOne(weights), sampleOne(weights)]; }
  function makePiece(key){ 
    return { 
      id: key, 
      cells: PIECES[key].map(p=>({r:p[0], c:p[1]})),
      color: PIECE_COLORS[key] || "#9aa5ff"
    }; 
  }

  function getFillRate(){
  let filled=0;
  for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++) {
    if(grid[r][c] || isDurablePiece(r,c) || isBonusPiece(r,c)) filled++;
    // Only count bomb pieces in Blast Mode
    if(currentGameMode === 'blast' && isBombPiece(r,c)) filled++;
  }
  return filled/(BOARD_SIZE*BOARD_SIZE);
}
  
  function isDurablePiece(r, c) {
    return durablePieces.some(piece => piece.r === r && piece.c === c);
  }
  
  function getDurablePiece(r, c) {
    return durablePieces.find(piece => piece.r === r && piece.c === c);
  }
  
  function generateDurablePieces() {
    let count = Math.floor(Math.random() * 7) + 6; // 6-12 pieces
    durablePieces = [];
    for(let i = 0; i < count; i++) {
      let r, c;
      do {
        r = Math.floor(Math.random() * BOARD_SIZE);
        c = Math.floor(Math.random() * BOARD_SIZE);
      } while(isDurablePiece(r, c) || (r === 0 && c === 0)); // Avoid top-left corner
      
      // Random durability 2-5
      let durability = Math.floor(Math.random() * 4) + 2;
      durablePieces.push({
        r: r, 
        c: c, 
        durability: durability,
        color: "#ff6b6b"
      });
    }
  }
  
  function generateBonusPieces() {
    // 30% chance to spawn bonus pieces after line clear
    if (Math.random() > 0.3) {
      console.log("Bonus spawn failed: 30% chance not met");
      return;
    }
    
    // Don't spawn if already at max (4 pieces)
    if (bonusPieces.length >= 4) {
      console.log("Bonus spawn failed: Already at max (4 pieces)");
      return;
    }
    
    // Find positions on EXISTING pieces (not empty cells) to place bonus on
    let availablePositions = [];
    for(let r = 0; r < BOARD_SIZE; r++) {
      for(let c = 0; c < BOARD_SIZE; c++) {
        // Only spawn on cells that have pieces (grid[r][c] = 1) or durable pieces
        if((grid[r][c] || isDurablePiece(r, c)) && !isBonusPiece(r, c)) {
          availablePositions.push({r: r, c: c});
        }
      }
    }
    
    if(availablePositions.length === 0) {
      console.log("Bonus spawn failed: No available positions on existing pieces");
      return;
    }
    
    console.log(`Bonus spawn: Found ${availablePositions.length} available positions on existing pieces`);
    
    // Spawn 2-3 bonus pieces
    let spawnCount = Math.floor(Math.random() * 2) + 2; // 2-3 pieces
    spawnCount = Math.min(spawnCount, 4 - bonusPieces.length, availablePositions.length);
    
    console.log(`Bonus spawn: Attempting to spawn ${spawnCount} pieces`);
    
    for(let i = 0; i < spawnCount; i++) {
      let posIndex = Math.floor(Math.random() * availablePositions.length);
      let pos = availablePositions.splice(posIndex, 1)[0];
      
      // Random multiplier: x2, x3, x4, x5, x6, x7
      let multipliers = [2, 3, 4, 5, 6, 7];
      let multiplier = multipliers[Math.floor(Math.random() * multipliers.length)];
      
      // Determine lifetime based on multiplier
      let lifetime;
      if(multiplier <= 3) lifetime = 4;      // x2, x3: 4 turns
      else if(multiplier <= 5) lifetime = 3; // x4, x5: 3 turns
      else lifetime = 2;                      // x6, x7: 2 turns
      
      bonusPieces.push({
        r: pos.r,
        c: pos.c,
        multiplier: multiplier,
        lifetime: lifetime,
        color: getBonusColor(multiplier)
      });
      
      console.log(`Bonus piece spawned: x${multiplier} at (${pos.r}, ${pos.c}) with ${lifetime} turns lifetime`);
    }
    
    console.log(`Total bonus pieces after spawn: ${bonusPieces.length}`);
  }
  
  function getBonusColor(multiplier) {
    // Color coding for different multipliers
    if(multiplier <= 3) return "#51cf66";      // Green for x2, x3
    else if(multiplier <= 5) return "#ffd43b"; // Yellow for x4, x5
    else return "#ff6b6b";                      // Red for x6, x7
  }
  
  function isBonusPiece(r, c) {
    return bonusPieces.some(piece => piece.r === r && piece.c === c);
  }
  
  function getBonusPiece(r, c) {
  return bonusPieces.find(piece => piece.r === r && piece.c === c);
}

function isBombPiece(r, c) {
  return bombPieces.some(piece => piece.r === r && piece.c === c);
}

function getBombPiece(r, c) {
  return bombPieces.find(piece => piece.r === r && piece.c === c);
}
  
  function addBonusText(text, x, y) {
  const bonusText = {
    text: text,
    x: x,
    y: y,
    startTime: Date.now(),
    id: Math.random()
  };
  bonusTexts.push(bonusText);
  
  // Remove after 2 seconds
  setTimeout(() => {
    bonusTexts = bonusTexts.filter(bt => bt.id !== bonusText.id);
  }, 2000);
}

function addBombText(text, x, y) {
  const bombText = {
    text: text,
    x: x,
    y: y,
    startTime: Date.now(),
    id: Math.random()
  };
  bombTexts.push(bombText);
  
  // Remove after 2 seconds
  setTimeout(() => {
    bombTexts = bombTexts.filter(bt => bt.id !== bombText.id);
  }, 2000);
}
  
  function drawBonusTexts() {
  const currentTime = Date.now();
  bonusTexts.forEach(bt => {
    let elapsed = currentTime - bt.startTime;
    let progress = elapsed / 2000; // 2 seconds total
    
    if(progress < 1) {
      ctx.save();
      ctx.globalAlpha = 1 - progress;
      ctx.font = "bold 32px system-ui";
      ctx.fillStyle = "#5de4c7";
      ctx.textAlign = "center";
      ctx.fillText(bt.text, bt.x, bt.y - progress * 30);
      ctx.restore();
    }
  });
}

function drawBombTexts() {
  const currentTime = Date.now();
  bombTexts.forEach(bt => {
    let elapsed = currentTime - bt.startTime;
    let progress = elapsed / 2000; // 2 seconds total
    
    if(progress < 1) {
      ctx.save();
      ctx.globalAlpha = 1 - progress;
      ctx.font = "bold 32px system-ui";
      ctx.fillStyle = "#ff6b6b";
      ctx.textAlign = "center";
      ctx.fillText(bt.text, bt.x, bt.y - progress * 30);
      ctx.restore();
    }
  });
}
  function canPlace(piece, R, C){
  for(const cell of piece.cells){
    let rr=R+cell.r, cc=C+cell.c;
    if(rr<0||rr>=BOARD_SIZE||cc<0||cc>=BOARD_SIZE) return false;
    if(grid[rr][cc] || isDurablePiece(rr, cc) || isBonusPiece(rr, cc)) return false;
    // Only check bomb pieces in Blast Mode
    if(currentGameMode === 'blast' && isBombPiece(rr, cc)) return false;
  }
  return true;
}
  function validPlacementsAny(p){
    for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++) if(canPlace(p, r, c)) return true;
    return false;
  }
  function placePiece(piece, R, C){
    let placed=0;
    for(const cell of piece.cells){ let rr=R+cell.r, cc=C+cell.c; grid[rr][cc]=1; placed++; }
    return placed;
  }
  function clearLines(){
    const clearedRows=[], clearedCols=[];
              for(let r=0;r<BOARD_SIZE;r++){ 
       let full=true; 
       for(let c=0;c<BOARD_SIZE;c++){ 
         // A line is full if it has pieces OR durable pieces OR bonus pieces (and bomb pieces only in Blast Mode)
         if(!grid[r][c] && !isDurablePiece(r,c) && !isBonusPiece(r,c)) {
           // Only check bomb pieces in Blast Mode
           if(currentGameMode === 'blast' && !isBombPiece(r,c)) {
             full=false;
             break;
           } else if(currentGameMode !== 'blast') {
             full=false;
             break;
           }
         }
       } 
       if(full) clearedRows.push(r); 
     }
     for(let c=0;c<BOARD_SIZE;c++){ 
       let full=true; 
       for(let r=0;r<BOARD_SIZE;r++){ 
         // A line is full if it has pieces OR durable pieces OR bonus pieces (and bomb pieces only in Blast Mode)
         if(!grid[r][c] && !isDurablePiece(r,c) && !isBonusPiece(r,c)) {
           // Only check bomb pieces in Blast Mode
           if(currentGameMode === 'blast' && !isBombPiece(r,c)) {
             full=false;
             break;
           } else if(currentGameMode !== 'blast') {
             full=false;
             break;
           }
         }
       } 
       if(full) clearedCols.push(c); 
     }
    
    // Check for cross clear bonus
    let crossBonus = 0;
    if(clearedRows.length > 0 && clearedCols.length > 0) {
      // Cross clear detected!
      let crossSize = clearedRows.length * clearedCols.length;
      if(crossSize === 1) crossBonus = 3;        // 1x1 cross: -3 durability
      else if(crossSize === 2) crossBonus = 4;   // 2x1 or I2 cross: -4 durability
      else if(crossSize === 4) crossBonus = 6;   // 2x2 cross: -6 durability
      else if(crossSize >= 6) crossBonus = 999;  // 2x3 or 3x2+ cross: clear all!
    }
    
    // Calculate bonus multipliers for cleared lines BEFORE clearing
    let totalBonusMultiplier = 1;
    let clearedBonusPieces = [];
    
    console.log(`Checking for bonus pieces in ${clearedRows.length} rows and ${clearedCols.length} columns`);
    
    // Check rows for bonus pieces
    for(let rr of clearedRows) {
      for(let c = 0; c < BOARD_SIZE; c++) {
        let bonusPiece = getBonusPiece(rr, c);
        if(bonusPiece) {
          console.log(`Found bonus piece x${bonusPiece.multiplier} in cleared row ${rr} at column ${c}`);
          totalBonusMultiplier *= bonusPiece.multiplier;
          clearedBonusPieces.push(bonusPiece);
        }
      }
    }
    
    // Check columns for bonus pieces
    for(let cc of clearedCols) {
      for(let r = 0; r < BOARD_SIZE; r++) {
        let bonusPiece = getBonusPiece(r, cc);
        if(bonusPiece) {
          console.log(`Found bonus piece x${bonusPiece.multiplier} in cleared column ${cc} at row ${r}`);
          totalBonusMultiplier *= bonusPiece.multiplier;
          clearedBonusPieces.push(bonusPiece);
        }
      }
    }
    
    console.log(`Total bonus multiplier: ${totalBonusMultiplier}, Cleared ${clearedBonusPieces.length} bonus pieces`);
    
    // Clear rows and columns, including durable pieces and bonus pieces
    // Track which pieces have been affected by cross bonus to avoid double-counting
    let affectedPieces = new Set();
    
    for(let rr of clearedRows){ 
      for(let c=0;c<BOARD_SIZE;c++) { 
        grid[rr][c]=0; 
        // Reduce durability of durable pieces in cleared rows
        let piece = getDurablePiece(rr, c);
        if(piece) {
          if(crossBonus >= 999) {
            piece.durability = 0; // Clear all for large cross
          } else {
            // For cross clear, only apply bonus once per piece
            if(affectedPieces.has(piece)) {
              piece.durability = Math.max(0, piece.durability - 1); // Normal line clear
            } else {
              piece.durability = Math.max(0, piece.durability - 1 - crossBonus); // First hit with bonus
              affectedPieces.add(piece);
            }
          }
        }
      } 
    }
    for(let cc of clearedCols){ 
      for(let r=0;r<BOARD_SIZE;r++) { 
        grid[r][cc]=0; 
        // Reduce durability of durable pieces in cleared columns
        let piece = getDurablePiece(r, cc);
        if(piece) {
          if(crossBonus >= 999) {
            piece.durability = 0; // Clear all for large cross
          } else {
            // For cross clear, only apply bonus once per piece
            if(affectedPieces.has(piece)) {
              piece.durability = Math.max(0, piece.durability - 1); // Normal line clear
            } else {
              piece.durability = Math.max(0, piece.durability - 1 - crossBonus); // First hit with bonus
              affectedPieces.add(piece);
            }
          }
        }
      } 
    }
    
    // Remove pieces with 0 durability
    durablePieces = durablePieces.filter(piece => piece.durability > 0);
    
    // Generate new bonus pieces after line clear (BEFORE removing cleared ones) - Only for Multiplier Mode
    if((clearedRows.length > 0 || clearedCols.length > 0) && currentGameMode === 'multiplier') {
      console.log(`Line clear detected: ${clearedRows.length} rows, ${clearedCols.length} cols`);
      console.log(`Bonus pieces before spawn: ${bonusPieces.length}`);
      generateBonusPieces();
      console.log(`Bonus pieces after spawn: ${bonusPieces.length}`);
    }
    
         // Remove cleared bonus pieces from the bonusPieces array (AFTER spawning new ones)
     bonusPieces = bonusPieces.filter(piece => 
       !clearedBonusPieces.some(cleared => cleared.r === piece.r && cleared.c === piece.c)
     );

           // Check for bombs in cleared lines and explode them - Only for Blast Mode
      let clearedBombs = [];
      if (currentGameMode === 'blast') {
        for(let rr of clearedRows) {
          for(let c = 0; c < BOARD_SIZE; c++) {
            if(isBombPiece(rr, c)) {
              clearedBombs.push({r: rr, c: c});
            }
          }
        }
        for(let cc of clearedCols) {
          for(let r = 0; r < BOARD_SIZE; r++) {
            if(isBombPiece(r, cc)) {
              clearedBombs.push({r: r, c: cc});
            }
          }
        }
      }
     
     // Explode bombs that are in cleared lines - Only for Blast Mode
     if (currentGameMode === 'blast') {
       for(let bomb of clearedBombs) {
         explodeBomb(bomb.r, bomb.c);
       }
     }

     // Try to generate bomb piece if conditions are met - Only for Blast Mode
     // Generate new bomb after line clear (allowing multiple bombs per game)
     if (currentGameMode === 'blast') {
       generateBombPiece();
     }
    
    return {
      rows: clearedRows, 
      cols: clearedCols, 
      crossBonus: crossBonus,
      bonusMultiplier: totalBonusMultiplier,
      clearedBonusPieces: clearedBonusPieces
    };
  }

  function getBiasFactor(FR){
    let f = biasCfg.base;
    if(FR > frWindow.high) f += biasCfg.alpha*(FR - frWindow.high);
    if(justDead) f += biasCfg.betaJustDead;
    return Math.min(f, biasCfg.cap);
  }

  function refillPool(){
    let FR = getFillRate();
    let weights = normalize(BASE_WEIGHTS);
    let factor = getBiasFactor(FR);
    weights = applyBias(weights, swapCfg.rescueSet, factor);
    
    // Always ensure we have 3 pieces - refill all null slots
    let refilledCount = 0;
    for(let i = 0; i < pool.length; i++) {
      if(pool[i] === null) {
        pool[i] = sampleOne(weights);
        refilledCount++;
      }
    }
    
    // Double check - if any slot is still null, fill it
    for(let i = 0; i < pool.length; i++) {
      if(pool[i] === null) {
        pool[i] = sampleOne(weights);
        refilledCount++;
      }
    }
    
    // Log refill info (hidden)
    // console.log(`Refilled ${refilledCount} slots. Pool now has:`, pool.map(p => p ? p.id : 'null'));
    // console.log('Pool array:', pool);
    // console.log('Pool length:', pool.length);
    // console.log('Pool null count:', pool.filter(p => p === null).length);
    
    let placeable = pool.some(pc => pc && validPlacementsAny(pc));

    if(!placeable){
      // Repair step 1: replace one with rescue
      let idx = Math.floor(rnd()*3);
      let rk = swapCfg.rescueSet[Math.floor(rnd()*swapCfg.rescueSet.length)];
      pool[idx] = makePiece(rk);
      placeable = pool.some(pc => pc && validPlacementsAny(pc));
      // Repair step 2: resample once if still dead
      if(!placeable){
        pool[idx] = sampleOne(weights);
        placeable = pool.some(pc => pc && validPlacementsAny(pc));
      }
    }

    // Update DSR window + guardrail
    recentDead.push(placeable?0:1); if(recentDead.length>guardrail.windowRefills) recentDead.shift();
    justDead = !placeable;
          if(!placeable){
        let sum = recentDead.reduce((a,b)=>a+b,0);
        if(sum >= guardrail.maxDead){
        // Force fix again
        let idx = Math.floor(rnd()*3);
        let rk = swapCfg.rescueSet[Math.floor(rnd()*swapCfg.rescueSet.length)];
        pool[idx] = makePiece(rk);
        placeable = pool.some(pc => pc && validPlacementsAny(pc));
        recentDead[recentDead.length-1] = placeable?0:1; // update last flag
        justDead = !placeable;
      }
    }

    comboLevel = 0; // reset combo at refill start
    comboStreak = 0; // reset combo streak at refill start
    
    // Try to generate bomb piece if conditions are met - Only for Blast Mode
    // Generate new bomb during pool refill (allowing multiple bombs per game)
    if (currentGameMode === 'blast') {
      generateBombPiece();
    }
    
         // Debug info
              debug(`Mode: ${currentGameMode.toUpperCase()}<br/>Pool: ${pool.filter(p => p !== null).length}/3 items<br/>Hold: ${hold.piece?'Yes':'No'} (CD:${hold.cd})<br/>Swap: CD ${swapCD}<br/>Pool state: [${pool.map(p => p ? p.id : 'null').join(', ')}]<br/>Pool array length: ${pool.length}<br/>Bonus: ${bonusPieces.length}/4 pieces<br/>Bomb: ${bombPieces.length} pieces<br/>Total Pieces: 65`);
    
    render();
  }

  function decreaseBonusLifetimes() {
    console.log(`Decreasing bonus lifetimes. Before: ${bonusPieces.length} pieces`);
    bonusPieces.forEach(piece => {
      piece.lifetime--;
      console.log(`Bonus piece x${piece.multiplier} at (${piece.r}, ${piece.c}) lifetime: ${piece.lifetime + 1} -> ${piece.lifetime}`);
    });
    let beforeCount = bonusPieces.length;
    bonusPieces = bonusPieces.filter(piece => piece.lifetime > 0);
    let afterCount = bonusPieces.length;
    if(beforeCount !== afterCount) {
      console.log(`Removed ${beforeCount - afterCount} expired bonus pieces. Remaining: ${afterCount}`);
    }
  }
  
  // Input mapping
  function gridAt(x,y){
    let gx = Math.floor((x-BOARD_X)/CELL);
    let gy = Math.floor((y-BOARD_Y)/CELL);
    if(gx>=0&&gx<BOARD_SIZE&&gy>=0&&gy<BOARD_SIZE) return {c:gx,r:gy};
    return null;
  }
  function poolSlotAt(x,y){
    // Three slots centered
    let gap = 12, box = 140;
    let totalW = box*3 + gap*2;
    let left = (W-totalW)/2;
    let top = POOL_Y;
    for(let i=0;i<3;i++){
      let rx=left + i*(box+gap), ry=top;
      if(x>=rx && x<=rx+box && y>=ry && y<=ry+box) return i;
    }
    return -1;
  }

  canvas.addEventListener('contextmenu', e=>e.preventDefault());
  
  // Touch and mouse event handling
  function handlePointerDown(e) {
    let rect = canvas.getBoundingClientRect();
    let x, y;
    
    if (e.type === 'touchstart') {
      x = e.touches[0].clientX - rect.left;
      y = e.touches[0].clientY - rect.top;
    } else {
      x = e.clientX - rect.left;
      y = e.clientY - rect.top;
    }
    
    if (e.button === 2) { // Right click
      selected.index = -1; 
      render(); 
      return; 
    }

    // If clicking pool slot -> start drag
    let slot = poolSlotAt(x, y);
    if (slot >= 0 && pool[slot] !== null) {
      // Always start drag for both mobile and desktop
      startDrag(pool[slot], x, y);
      return;
    }

    // If have selection and not mobile, try placing on board
    if (selected.index >= 0 && !isMobile) {
      let g = gridAt(x, y);
      if (g) {
        let piece = pool[selected.index];
        if (canPlace(piece, g.r, g.c)) {
          placePieceOnBoard(piece, g.r, g.c);
        }
      }
    }

    // If click on hold area to release
    let holdRect = {x: 40, y: POOL_Y+160, w: 180, h: 80};
    if (x >= holdRect.x && x <= holdRect.x+holdRect.w && y >= holdRect.y && y <= holdRect.y+holdRect.h) {
      if (hold.piece) {
        let emptySlot = pool.findIndex(p => p === null);
        if (emptySlot !== -1) {
          pool[emptySlot] = hold.piece;
          hold.piece = null;
          render();
          return;
        }
      }
    }
  }
  
  function handlePointerMove(e) {
    if (!isDragging) return;
    
    let rect = canvas.getBoundingClientRect();
    let x, y;
    
    if (e.type === 'touchmove') {
      x = e.touches[0].clientX - rect.left;
      y = e.touches[0].clientY - rect.top;
    } else {
      x = e.clientX - rect.left;
      y = e.clientY - rect.top;
    }
    
    updateDrag(x, y);
  }
  
  function handlePointerUp(e) {
    if (isDragging) {
      endDrag();
    }
  }
  
  // Add event listeners
  canvas.addEventListener('mousedown', handlePointerDown);
  canvas.addEventListener('mousemove', handlePointerMove);
  canvas.addEventListener('mouseup', handlePointerUp);
  
  // Touch events for mobile
  canvas.addEventListener('touchstart', handlePointerDown, { passive: false });
  canvas.addEventListener('touchmove', handlePointerMove, { passive: false });
  canvas.addEventListener('touchend', handlePointerUp, { passive: false });
  
  // Prevent default touch behavior
  canvas.addEventListener('touchstart', e => e.preventDefault(), { passive: false });
  canvas.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
  
  // Helper function to place piece on board
  function placePieceOnBoard(piece, r, c) {
    let placedCells = placePiece(piece, r, c);
    let cleared = clearLines();
    
    // scoring
    const lines = cleared.rows.length + cleared.cols.length;
    let baseScore = placedCells*scoring.cell + lines*scoring.line;
    
    // Apply bonus multiplier if any bonus pieces were cleared
    if(cleared.bonusMultiplier > 1) {
      let bonusScore = baseScore * (cleared.bonusMultiplier - 1);
      score += baseScore + bonusScore;
      
      // Display bonus score text
      let centerX = BOARD_X + (BOARD_SIZE * CELL) / 2;
      let centerY = BOARD_Y + (BOARD_SIZE * CELL) / 2;
      addBonusText(`+${bonusScore}`, centerX, centerY + 120);
    } else {
      score += baseScore;
    }
    
    // Precision bonus only for Blocker Mode
    if (currentGameMode === 'blocker') {
      if(lines>=3) score = Math.floor(score*scoring.precisionThree);
      else if(lines>=2) score = Math.floor(score*scoring.precisionTwo);
    }
    
    // combo
    if(lines>0) comboLevel = Math.min(comboLevel+1, scoring.comboSteps.length-1);
    else comboLevel = 0;
    score = Math.floor(score * Math.min(scoring.comboSteps[comboLevel], scoring.comboCap));
    
    // Add combo text based on consecutive streak
    if(lines > 0) {
      comboStreak++;
      let centerX = BOARD_X + (BOARD_SIZE * CELL) / 2;
      let centerY = BOARD_Y + (BOARD_SIZE * CELL) / 2;
      
      let comboText = "Good";
      if(comboStreak >= 10) comboText = "Ultimate!";
      else if(comboStreak >= 9) comboText = "Godlike!";
      else if(comboStreak >= 8) comboText = "Legendary!";
      else if(comboStreak >= 7) comboText = "Unbelievable!";
      else if(comboStreak >= 6) comboText = "Incredible!";
      else if(comboStreak >= 5) comboText = "Fantastic!";
      else if(comboStreak >= 4) comboText = "Amazing!";
      else if(comboStreak >= 3) comboText = "Great!";
      else if(comboStreak >= 2) comboText = "Nice!";
      
      if(cleared.crossBonus > 0) {
        let bonusText = "";
        if(cleared.crossBonus >= 999) bonusText = "CLEAR ALL!";
        else if(cleared.crossBonus >= 6) bonusText = "MEGA CROSS!";
        else if(cleared.crossBonus >= 4) bonusText = "BIG CROSS!";
        else if(cleared.crossBonus >= 3) bonusText = "CROSS!";
        
        if(bonusText) {
          addComboText(bonusText, centerX, centerY + 60);
        }
      }
      
      addComboText(comboText, centerX, centerY);
    } else {
      comboStreak = 0;
    }

    // consume piece
    pool[selected.index] = null;
    selected.index = -1;
    turn++;
    if(swapCD>0) swapCD--;
    if(hold.cd>0) hold.cd--;
    
    // Decrease bonus piece lifetimes
    decreaseBonusLifetimes();
    
    // Decrease bomb lifetimes - Only for Blast Mode
    if (currentGameMode === 'blast') {
      decreaseBombLifetimes();
    }

    // Render FIRST to show the placed piece AND cleared lines
    render();
    
    // THEN check for game over (after lines have been cleared)
    if(checkGameOver()) {
      gameOver = true;
      render();
      return;
    }
    
    // Auto refill pool if it's empty
    if(pool.every(p => p === null)) {
      refillPool();
      return;
    }
  }

  // UI buttons via keys for simplicity
  window.addEventListener('keydown', (e)=>{
    if(e.key==='h' || e.key==='H'){
      // Hold selected piece - chỉ khi có khối được chọn và hold slot trống
      if(selected.index>=0 && !hold.piece && hold.cd<=0){
        hold.piece = pool[selected.index];
        pool[selected.index] = null;
        hold.cd = holdCfg.cdTurns;
        selected.index=-1;
        
        // Auto refill if pool is empty
        if(pool.every(p => p === null)) {
          refillPool();
        } else {
          render();
        }
      }
    } else if(e.key==='1' || e.key==='2' || e.key==='3'){
      // Swap piece index 0/1/2 - chỉ khi swapCD = 0
      let idx = parseInt(e.key,10)-1;
      if(idx>=0 && idx<pool.length){
        if(swapCD<=0){
          let rk = swapCfg.rescueSet[Math.floor(rnd()*swapCfg.rescueSet.length)];
          pool[idx] = makePiece(rk);
          swapCD = swapCfg.cdTurns;
          
          // Check for game over after swap
          if(checkGameOver()) {
            gameOver = true;
          }
          render();
        }
      }
    }
  });

  function drawBoard(){
    // Debug: Log bonus pieces state
    if(bonusPieces.length > 0) {
      console.log(`Drawing ${bonusPieces.length} bonus pieces:`, bonusPieces);
    }
    
    // grid
    for(let r=0;r<BOARD_SIZE;r++){
      for(let c=0;c<BOARD_SIZE;c++){
        let x = BOARD_X + c*CELL, y = BOARD_Y + r*CELL;
        
        if(isDurablePiece(r, c)) {
          // Draw durable piece with durability number
          let piece = getDurablePiece(r, c);
          let durability = piece.durability;
          
          // Color based on durability (darker = higher durability)
          let intensity = Math.max(0.3, durability / 5);
          ctx.fillStyle = `rgba(247, 118, 142, ${intensity})`;
          ctx.fillRect(x+2,y+2,CELL-4,CELL-4);
          ctx.strokeStyle = "#d73a49";
          ctx.lineWidth = 2;
          ctx.strokeRect(x+2, y+2, CELL-4, CELL-4);
          
          // Draw durability number
          ctx.fillStyle = "#ffffff";
          ctx.font = "bold 16px system-ui";
          ctx.textAlign = "center";
          ctx.fillText(durability.toString(), x + CELL/2, y + CELL/2 + 5);
                 } else if(currentGameMode === 'blast' && isBombPiece(r, c)) {
           // Draw bomb piece with distinct black color and red border - Only for Blast Mode
           let piece = getBombPiece(r, c);
           let lifetime = piece.lifetime;
           
           // Black background with red border
           ctx.fillStyle = "#000000";
           ctx.fillRect(x+2,y+2,CELL-4,CELL-4);
           ctx.strokeStyle = "#ff0000";
           ctx.lineWidth = 3;
           ctx.strokeRect(x+2, y+2, CELL-4, CELL-4);
           
           // Draw "BOMB" text
           ctx.fillStyle = "#ffffff";
           ctx.font = "bold 10px system-ui";
           ctx.textAlign = "center";
           ctx.fillText("BOMB", x + CELL/2, y + CELL/2 + 5);
           
           // Draw lifetime indicator
           ctx.fillStyle = "#ff0000";
           ctx.font = "bold 12px system-ui";
           ctx.fillText(`${lifetime}`, x + CELL/2, y + CELL/2 + 20);
         } else if(isBonusPiece(r, c)) {
           // Draw bonus piece with multiplier
           let piece = getBonusPiece(r, c);
           let multiplier = piece.multiplier;
           
           console.log(`Drawing bonus piece x${multiplier} at (${r}, ${c}) with color ${piece.color}`);
           
           ctx.fillStyle = piece.color;
           ctx.fillRect(x+2,y+2,CELL-4,CELL-4);
           ctx.strokeStyle = "#ffffff";
           ctx.lineWidth = 2;
           ctx.strokeRect(x+2, y+2, CELL-4, CELL-4);
           
           // Draw multiplier (x2, x3, etc.)
           ctx.fillStyle = "#ffffff";
           ctx.font = "bold 14px system-ui";
           ctx.textAlign = "center";
           ctx.fillText(`x${multiplier}`, x + CELL/2, y + CELL/2 + 5);
           
           // Draw lifetime indicator
           ctx.fillStyle = "#ffffff";
           ctx.font = "10px system-ui";
           ctx.fillText(`${piece.lifetime}`, x + CELL/2, y + CELL/2 + 20);
         } else if(grid[r][c]) {
          // Draw placed piece
          ctx.fillStyle = "#5865f2";
          ctx.fillRect(x+2,y+2,CELL-4,CELL-4);
        } else {
          // Draw empty cell
          ctx.fillStyle = "#1c2342";
          ctx.fillRect(x+2,y+2,CELL-4,CELL-4);
          ctx.strokeStyle = "#2a3156";
          ctx.lineWidth = 1;
          ctx.strokeRect(x+2, y+2, CELL-4, CELL-4);
        }
      }
    }
    
    // header stats
    let FR = getFillRate();
    let multiplier = Math.min(scoring.comboSteps[comboLevel], scoring.comboCap).toFixed(2);
    ctx.fillStyle="#E8EBF7";
    ctx.font="bold 16px system-ui";
    ctx.fillText(`Điểm: ${score}`, BOARD_X, BOARD_Y-12);
    ctx.fillText(`FR: ${(FR*100).toFixed(0)}%`, BOARD_X+150, BOARD_Y-12);
    ctx.fillText(`Chain ×${multiplier}`, BOARD_X+250, BOARD_Y-12);
    
    // Game mode indicator
    ctx.fillStyle = "#5de4c7";
    ctx.font = "bold 14px system-ui";
    ctx.fillText(`${getModeDisplayName(currentGameMode)}`, BOARD_X+400, BOARD_Y-12);
    
    // High score indicator
    if(score >= highScore && score > 0) {
      ctx.fillStyle = "#ffd43b";
      ctx.font = "bold 14px system-ui";
      ctx.fillText("🏆 HIGH SCORE!", BOARD_X+400, BOARD_Y-28);
    }
  }

  function drawPieceAt(piece, px, py, scale=1.0, color=null){
    let size = CELL*scale;
    // compute min bounds to align
    let minr=Infinity, minc=Infinity;
    for(const cell of piece.cells){ if(cell.r<minr) minr=cell.r; if(cell.c<minc) minc=cell.c; }
    
    // Use piece color if available, otherwise use provided color
    let pieceColor = color || piece.color || "#9aa5ff";
    
    for(const cell of piece.cells){
      let x = px + (cell.c - minc)*size;
      let y = py + (cell.r - minr)*size;
      ctx.fillStyle = pieceColor;
      ctx.fillRect(x+3,y+3,size-6,size-6);
      ctx.strokeStyle="#101425"; ctx.lineWidth=2; ctx.strokeRect(x+3,y+3,size-6,size-6);
    }
  }

  function drawPool(){
    let gap = 12, box = 140;
    let totalW = box*3 + gap*2;
    let left = (W-totalW)/2;
    let top = POOL_Y;

    // Draw pool title
    ctx.fillStyle = "#E8EBF7";
    ctx.font = "bold 16px system-ui";
    ctx.fillText("POOL - Chọn khối để đặt", left, top - 20);
    
    // Debug: Show pool state (hidden)
    // ctx.fillStyle = "#f7768e";
    // ctx.font = "12px system-ui";
    // ctx.fillText(`Debug: Pool has ${pool.filter(p => p !== null).length}/3 pieces`, left, top - 5);
    
    ctx.font="bold 14px system-ui";
    for(let i=0;i<3;i++){
      let x=left+i*(box+gap), y=top;
      
      // Always draw all 3 slots regardless of content
      ctx.strokeStyle = (selected.index===i?"#5de4c7":"#2a3156");
      ctx.lineWidth = 3;
      ctx.strokeRect(x, y, box, box);
      
      // Slot background
      ctx.fillStyle = "rgba(43, 51, 92, 0.3)";
      ctx.fillRect(x+1, y+1, box-2, box-2);

      if(pool[i] !== null){
        // Draw piece
        drawPieceAt(pool[i], x+20, y+20, 0.6, selected.index===i?"#5de4c7":null);
      } else {
        // Show empty slot
        ctx.fillStyle="#2a3156"; 
        ctx.fillRect(x+20, y+20, 100, 100);
        ctx.strokeStyle = "#3a4376";
        ctx.strokeRect(x+20, y+20, 100, 100);
        ctx.fillStyle = "#8b90a7";
        ctx.font = "12px system-ui";
        ctx.fillText("Empty", x+box/2-20, y+box/2+5);
      }
      
      // Slot label
      ctx.fillStyle="#E8EBF7";
      ctx.fillText(`Slot ${i+1}`, x+6, y+16);
      
      // Swap tip - positioned above each slot
      ctx.fillStyle = swapCD>0? "#8b90a7" : "#a6da95";
      ctx.font = "12px system-ui";
      ctx.fillText(`Swap: phím ${i+1} ${swapCD>0?`(CD ${swapCD})`:""}`, x+box/2-30, y-8);
    }

    // Hold panel - moved to better position
    let hx=40, hy=POOL_Y+160, hw=180, hh=80;
    ctx.strokeStyle="#2a3156"; 
    ctx.lineWidth = 2;
    ctx.strokeRect(hx,hy,hw,hh);
    
    // Hold background
    ctx.fillStyle = "rgba(43, 51, 92, 0.3)";
    ctx.fillRect(hx+1, hy+1, hw-2, hh-2);
    
    ctx.fillStyle="#E8EBF7"; 
    ctx.font = "bold 14px system-ui";
    ctx.fillText("Hold (phím H)", hx+8, hy+16);
    ctx.fillText(hold.cd>0?`CD: ${hold.cd}`:"", hx+8, hy+34);
    
    if(hold.piece){ 
      drawPieceAt(hold.piece, hx+100, hy+20, 0.45, "#ffd580"); 
    } else {
      // Show empty hold slot
      ctx.fillStyle = "#2a3156";
      ctx.fillRect(hx+100, hy+20, 60, 60);
      ctx.strokeStyle = "#3a4376";
      ctx.strokeRect(hx+100, hy+20, 60, 60);
    }

    // Hint
    ctx.fillStyle="#8b90a7";
    ctx.fillText("Chọn Slot → click ô bàn để đặt. Chuột phải: bỏ chọn.", W-370, POOL_Y+200);
  }

  function render(){
    ctx.clearRect(0,0,W,H);
    
    // Debug: Log pool state before drawing (hidden)
    // console.log('Render - Pool state:', pool);
    // console.log('Render - Pool length:', pool.length);
    // console.log('Render - Pool null count:', pool.filter(p => p === null).length);
    
    drawBoard();
    drawPool();
    drawComboTexts();
    drawBonusTexts();
    
    // Only draw bomb texts in Blast Mode
    if (currentGameMode === 'blast') {
      drawBombTexts();
    }
    
    // Draw drop preview if dragging
    if (dropPreview) {
      drawDropPreview();
    }
    
    // Draw dragged piece if dragging
    if (isDragging && draggedPiece) {
      drawDraggedPiece();
    }
    
    updateStats();

    let FR = getFillRate();
    let fairness = justDead? "Có lượt kẹt gần đây" : "Ổn";
    let ftxt = FR>0.7? "Căng" : (FR<0.3? "Rộng" : "Đẹp");
    
    let controlText = isMobile ? 
      "Touch & Drag: Chọn khối → kéo lên bàn chơi • Nút Hold/Swap bên dưới" :
      "Swap: phím 1/2/3 • Hold: phím H • Chuột phải: bỏ chọn";
    
    msg(
      `<h3>📊 Thông Tin Game</h3>` +
      `Turn <b>${turn}</b> • <span class="${FR<0.3?"ok":(FR>0.7?"bad":"warn")}">FR: ${(FR*100).toFixed(0)}% (${ftxt})</span>` +
      ` • High Score: <span class="hl">${highScore}</span><br/>` +
      `<span class="legend">${controlText}</span>` +
      `<br/><br/><button onclick="resetGame()" style="background: linear-gradient(145deg, #5de4c7, #4a5386); color: #0f1220; border: none; border-radius: 12px; padding: 12px 24px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">🔄 Chơi Lại</button>`
    );
    
    // Show game over text if game is over
    if(gameOver) {
      document.getElementById('game-over-overlay').style.display = 'block';
      document.getElementById('final-score').textContent = score;
      document.getElementById('current-mode-display').textContent = getModeDisplayName(currentGameMode);
    } else {
      document.getElementById('game-over-overlay').style.display = 'none';
    }
  }
  
  function drawDropPreview() {
    if (!dropPreview) return;
    
    ctx.save();
    ctx.globalAlpha = 0.6;
    
    let piece = dropPreview.piece;
    let r = dropPreview.r;
    let c = dropPreview.c;
    
    for (const cell of piece.cells) {
      let rr = r + cell.r, cc = c + cell.c;
      if (rr >= 0 && rr < BOARD_SIZE && cc >= 0 && cc < BOARD_SIZE) {
        let x = BOARD_X + cc * CELL;
        let y = BOARD_Y + rr * CELL;
        
        ctx.fillStyle = "#5de4c7";
        ctx.fillRect(x + 2, y + 2, CELL - 4, CELL - 4);
        ctx.strokeStyle = "#5de4c7";
        ctx.lineWidth = 2;
        ctx.strokeRect(x + 2, y + 2, CELL - 4, CELL - 4);
      }
    }
    
    ctx.restore();
  }
  
  function drawDraggedPiece() {
    if (!draggedPiece || !isDragging) return;
    
    ctx.save();
    ctx.globalAlpha = 0.8;
    
    // Draw piece at drag position
    let x = dragOffset.x - (CELL * 0.3);
    let y = dragOffset.y - (CELL * 0.3);
    
    drawPieceAt(draggedPiece, x, y, 0.6);
    
    ctx.restore();
  }

  function generateBombPiece() {
     // Only spawn if Fill Rate >= 50%
   let FR = getFillRate();
   if (FR < 0.5) {
     console.log(`Bomb spawn failed: FR=${FR.toFixed(2)} (need >=0.5)`);
     return;
   }

   // Don't spawn if already at max (1 bomb at a time)
   if (bombPieces.length >= 1) {
     console.log("Bomb spawn failed: Already at max (1 bomb at a time)");
     return;
   }

  // Find positions on EXISTING pieces (not empty cells) to place bomb on
  let availablePositions = [];
  for(let r = 0; r < BOARD_SIZE; r++) {
    for(let c = 0; c < BOARD_SIZE; c++) {
      // Only spawn on cells that have pieces (grid[r][c] = 1) or durable pieces
      if((grid[r][c] || isDurablePiece(r, c)) && !isBonusPiece(r, c) && !isBombPiece(r, c)) {
        availablePositions.push({r: r, c: c});
      }
    }
  }
  
  if(availablePositions.length === 0) {
    console.log("Bomb spawn failed: No available positions on existing pieces");
    return;
  }

  // Pick random position from available ones
  let posIndex = Math.floor(Math.random() * availablePositions.length);
  let pos = availablePositions[posIndex];
  
  // Random lifetime 1-2 turns
  let lifetime = Math.floor(Math.random() * 2) + 1;

  bombPieces.push({
    r: pos.r,
    c: pos.c,
    lifetime: lifetime,
    color: "#000000" // Black color for bomb to distinguish from durable pieces
  });
  
     console.log(`Bomb spawned at (${pos.r}, ${pos.c}) with ${lifetime} turns lifetime. FR was ${FR.toFixed(2)}`);
}

  function decreaseBombLifetimes() {
    console.log(`Decreasing bomb lifetimes. Before: ${bombPieces.length} pieces`);
    bombPieces.forEach(piece => {
      piece.lifetime--;
      console.log(`Bomb at (${piece.r}, ${piece.c}) lifetime: ${piece.lifetime + 1} -> ${piece.lifetime}`);
    });
    let beforeCount = bombPieces.length;
    bombPieces = bombPieces.filter(piece => piece.lifetime > 0);
    let afterCount = bombPieces.length;
    if(beforeCount !== afterCount) {
      console.log(`Removed ${beforeCount - afterCount} expired bomb pieces. Remaining: ${afterCount}`);
    }
  }

  function explodeBomb(bombR, bombC) {
  console.log(`Bomb exploded at (${bombR}, ${bombC})!`);

  let explosionScore = 0;
  let bonusPiecesActivated = [];

  // Clear all pieces in the 3x3 area around the bomb
  for(let r = bombR - 1; r <= bombR + 1; r++) {
    for(let c = bombC - 1; c <= bombC + 1; c++) {
      if(r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
        if(grid[r][c] || isDurablePiece(r, c) || isBonusPiece(r, c)) {
          // If it's a durable piece, reduce its durability
          let piece = getDurablePiece(r, c);
          if(piece) {
            piece.durability = Math.max(0, piece.durability - 1);
            console.log(`Durable piece at (${r}, ${c}) durability reduced to ${piece.durability}`);
            explosionScore += 1; // Score for hitting durable piece
          }
          
          // If it's a bonus piece, activate it and add to score
          let bonusPiece = getBonusPiece(r, c);
          if(bonusPiece) {
            bonusPiecesActivated.push(bonusPiece);
            explosionScore += bonusPiece.multiplier; // Score for bonus piece
            console.log(`Bonus piece x${bonusPiece.multiplier} at (${r}, ${c}) activated by explosion!`);
          }
          
          // Clear the cell
          grid[r][c] = 0;
          explosionScore += 1; // Score for clearing regular piece
          console.log(`Cell at (${r}, ${c}) cleared.`);
        }
      }
    }
  }

  // Remove pieces with 0 durability
  durablePieces = durablePieces.filter(piece => piece.durability > 0);
  
  // Remove activated bonus pieces
  bonusPieces = bonusPieces.filter(piece => 
    !bonusPiecesActivated.some(activated => activated.r === piece.r && activated.c === piece.c)
  );

  // Add explosion score text
  let centerX = BOARD_X + (BOARD_SIZE * CELL) / 2;
  let centerY = BOARD_Y + (BOARD_SIZE * CELL) / 2;
  addBombText(`💥 BOOM! +${explosionScore}`, centerX, centerY + 120);

  // Add score for explosion
  score += explosionScore;
  
  // Remove the bomb piece that exploded
  bombPieces = bombPieces.filter(bomb => !(bomb.r === bombR && bomb.c === bombC));
  console.log(`Bomb exploded, score added: +${explosionScore}, bomb pieces remaining: ${bombPieces.length}`);
}

  // Event Listeners for Game Mode System
  document.addEventListener('DOMContentLoaded', function() {
    // Mode selector buttons
    document.querySelectorAll('.mode-button[data-mode]').forEach(button => {
      button.addEventListener('click', function() {
        const mode = this.getAttribute('data-mode');
        selectGameMode(mode);
      });
    });
    
    // Other mode buttons in game over screen
    document.querySelectorAll('.other-mode-btn').forEach(button => {
      button.addEventListener('click', function() {
        const mode = this.getAttribute('data-mode');
        selectGameMode(mode);
      });
    });
    
    // Mobile control buttons
    if (isMobile) {
      document.getElementById('hold-btn').addEventListener('click', function() {
        if (selected.index >= 0 && !hold.piece && hold.cd <= 0) {
          hold.piece = pool[selected.index];
          pool[selected.index] = null;
          hold.cd = holdCfg.cdTurns;
          selected.index = -1;
          
          // Auto refill if pool is empty
          if(pool.every(p => p === null)) {
            refillPool();
          } else {
            render();
          }
        }
      });
      
      document.getElementById('swap1-btn').addEventListener('click', function() {
        if (swapCD <= 0) {
          let rk = swapCfg.rescueSet[Math.floor(rnd()*swapCfg.rescueSet.length)];
          pool[0] = makePiece(rk);
          swapCD = swapCfg.cdTurns;
          
          // Check for game over after swap
          if(checkGameOver()) {
            gameOver = true;
          }
          render();
        }
      });
      
      document.getElementById('swap2-btn').addEventListener('click', function() {
        if (swapCD <= 0) {
          let rk = swapCfg.rescueSet[Math.floor(rnd()*swapCfg.rescueSet.length)];
          pool[1] = makePiece(rk);
          swapCD = swapCfg.cdTurns;
          
          // Check for game over after swap
          if(checkGameOver()) {
            gameOver = true;
          }
          render();
        }
      });
      
      document.getElementById('swap3-btn').addEventListener('click', function() {
        if (swapCD <= 0) {
          let rk = swapCfg.rescueSet[Math.floor(rnd()*swapCfg.rescueSet.length)];
          pool[2] = makePiece(rk);
          swapCD = swapCfg.cdTurns;
          
          // Check for game over after swap
          if(checkGameOver()) {
            gameOver = true;
          }
          render();
        }
      });
    }
    
    // Initialize high score display
    updateHighScoreDisplay();
    
    // Show mode selector at startup
    showModeSelector();
  });
  
  // Boot
  if (currentGameMode === 'blocker') {
    generateDurablePieces();
  }
  
  // Ensure pool starts with 3 pieces
  pool = [null, null, null];
  
  refillPool();
  
  // Double check pool has 3 pieces
  if(pool.some(p => p === null)) {
    refillPool();
  }

  render();
})();
</script>
</body>
</html>
