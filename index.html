<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Block Tetrist - Game ƒê·∫∑t Kh·ªëi Th√¥ng Minh</title>
<style>
  * { box-sizing: border-box; }
  html, body { 
    margin: 0; 
    padding: 0; 
    background: linear-gradient(135deg, #0f1220 0%, #1a1f3a 100%);
    color: #E8EBF7; 
    font-family: 'Segoe UI', system-ui, -apple-system, Roboto, Arial, sans-serif;
    overflow-x: hidden;
  }
  
  #wrap { 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    gap: 16px; 
    padding: 20px; 
    min-height: 100vh;
  }
  
  .header {
    text-align: center;
    margin-bottom: 20px;
  }
  
  .header h1 {
    margin: 0;
    font-size: 32px;
    font-weight: 700;
    background: linear-gradient(45deg, #5de4c7, #8093ff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  
  .header .subtitle {
    margin: 8px 0 0;
    font-size: 16px;
    opacity: 0.8;
    color: #a6da95;
  }
  
  canvas { 
    background: linear-gradient(145deg, #151a2d, #1c2342);
    border: 2px solid #2a3156; 
    border-radius: 16px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
    position: relative;
  }
  
  canvas:hover {
    border-color: #3a4376;
    box-shadow: 0 12px 40px rgba(0,0,0,0.4);
  }
  
  .row { 
    display: flex; 
    flex-wrap: wrap; 
    gap: 16px; 
    justify-content: center; 
    align-items: flex-start; 
    max-width: 1200px;
  }
  
  .card { 
    background: linear-gradient(145deg, #161a30, #1a1f3a);
    border: 1px solid #2b335c; 
    padding: 16px 20px; 
    border-radius: 16px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.2);
    transition: all 0.3s ease;
    min-width: 300px;
  }
  
  .card:hover {
    border-color: #3a4376;
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(0,0,0,0.3);
  }
  
  button { 
    background: linear-gradient(145deg, #2a3156, #3a4376);
    color: #E8EBF7; 
    border: none;
    border-radius: 12px; 
    padding: 12px 20px; 
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
  }
  
  button:hover:not([disabled]) {
    background: linear-gradient(145deg, #3a4376, #4a5386);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  }
  
  button[disabled] { 
    opacity: 0.45; 
    cursor: not-allowed;
    transform: none;
  }
  
  .stat { 
    margin: 4px 12px; 
    font-size: 14px; 
    opacity: 0.9; 
  }
  
  .legend { 
    font-size: 14px; 
    opacity: 0.9; 
    line-height: 1.6; 
  }
  
  .hl { 
    color: #5de4c7; 
    font-weight: 600; 
  }
  
  .warn { 
    color: #f9c859; 
  }
  
  .bad { 
    color: #f7768e; 
  }
  
  .ok { 
    color: #a6da95; 
  }
  
  .version { 
    position: absolute; 
    top: 20px; 
    right: 20px; 
    font-size: 12px; 
    opacity: 0.6;
    background: rgba(26, 26, 26, 0.8);
    padding: 8px 12px;
    border-radius: 20px;
    backdrop-filter: blur(10px);
  }
  
  .debug { 
    position: absolute; 
    top: 60px; 
    right: 20px; 
    font-size: 11px; 
    opacity: 0.8; 
    background: rgba(26, 26, 26, 0.9); 
    padding: 8px 12px; 
    border-radius: 8px;
    backdrop-filter: blur(10px);
    max-width: 200px;
  }
  
  .controls-info {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 16px;
    margin-top: 20px;
  }
  
  .control-group {
    background: rgba(43, 51, 92, 0.3);
    padding: 16px;
    border-radius: 12px;
    border-left: 4px solid #5de4c7;
  }
  
  .control-group h3 {
    margin: 0 0 12px 0;
    font-size: 16px;
    color: #5de4c7;
  }
  
  .key {
    background: #2a3156;
    padding: 4px 8px;
    border-radius: 6px;
    font-family: monospace;
    font-weight: bold;
    color: #5de4c7;
  }
  
  .stats-display {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    justify-content: center;
    margin: 20px 0;
  }
  
  .stat-item {
    background: rgba(43, 51, 92, 0.3);
    padding: 12px 20px;
    border-radius: 12px;
    text-align: center;
    min-width: 120px;
  }
  
  .stat-value {
    font-size: 24px;
    font-weight: bold;
    color: #5de4c7;
    margin-bottom: 4px;
  }
  
  .stat-label {
    font-size: 12px;
    opacity: 0.7;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  
     /* Game Over Text Overlay */
   .game-over-text {
     position: absolute;
     top: 50%;
     left: 50%;
     transform: translate(-50%, -50%);
     background: linear-gradient(145deg, #161a30, #1a1f3a);
     border: 2px solid #f7768e;
     border-radius: 16px;
     padding: 20px;
     text-align: center;
     box-shadow: 0 8px 24px rgba(0,0,0,0.6);
     z-index: 1000;
     min-width: 200px;
   }
   
   .game-over-title {
     font-size: 18px;
     font-weight: bold;
     color: #f7768e;
     margin-bottom: 12px;
   }
   
   .game-over-button {
     background: linear-gradient(145deg, #5de4c7, #4a5386);
     color: #0f1220;
     font-size: 14px;
     font-weight: bold;
     padding: 8px 16px;
     border: none;
     border-radius: 8px;
     cursor: pointer;
     transition: all 0.3s ease;
   }
   
   .game-over-button:hover {
     background: linear-gradient(145deg, #4a5386, #5de4c7);
     transform: translateY(-1px);
     box-shadow: 0 4px 12px rgba(93, 228, 199, 0.3);
   }
  
  /* Combo Text Animation */
  .combo-text {
    position: absolute;
    font-size: 48px;
    font-weight: bold;
    color: #5de4c7;
    text-shadow: 0 0 20px rgba(93, 228, 199, 0.8);
    pointer-events: none;
    z-index: 100;
    animation: comboFadeOut 2s ease-out forwards;
  }
  
  @keyframes comboFadeOut {
    0% {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
    50% {
      opacity: 1;
      transform: scale(1.2) translateY(-20px);
    }
    100% {
      opacity: 0;
      transform: scale(1.5) translateY(-40px);
    }
  }
  
  @media (max-width: 768px) {
    #wrap { padding: 16px; }
    .header h1 { font-size: 24px; }
    .row { flex-direction: column; align-items: center; }
    .card { min-width: 280px; }
    .stats-display { flex-direction: column; align-items: center; }
         .game-over-text { padding: 16px; min-width: 160px; }
     .game-over-title { font-size: 16px; }
  }
  
  /* Game Mode Selector Styles */
  .mode-selector {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(15, 18, 32, 0.9);
    backdrop-filter: blur(10px);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
  }
  
  .mode-selector-content {
    background: linear-gradient(145deg, #161a30, #1a1f3a);
    border: 2px solid #5de4c7;
    border-radius: 20px;
    padding: 30px;
    max-width: 800px;
    text-align: center;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
  }
  
  .mode-selector h2 {
    margin: 0 0 30px 0;
    font-size: 28px;
    background: linear-gradient(45deg, #5de4c7, #8093ff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  
  .mode-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 20px;
    margin-top: 20px;
  }
  
  .mode-button {
    background: linear-gradient(145deg, #2a3156, #3a4376);
    border: 2px solid #2a3156;
    border-radius: 16px;
    padding: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: center;
    min-height: 140px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }
  
  .mode-button:hover {
    border-color: #5de4c7;
    transform: translateY(-4px);
    box-shadow: 0 8px 25px rgba(93, 228, 199, 0.3);
  }
  
  .mode-icon {
    font-size: 32px;
    margin-bottom: 8px;
  }
  
  .mode-title {
    font-size: 18px;
    font-weight: bold;
    color: #5de4c7;
    margin-bottom: 6px;
  }
  
  .mode-desc {
    font-size: 12px;
    opacity: 0.8;
    margin-bottom: 12px;
    line-height: 1.4;
  }
  
  .mode-highscore {
    font-size: 11px;
    color: #a6da95;
    font-weight: 600;
  }
  
     /* High Score Display */
   .high-score-display {
     position: absolute;
     top: 20px;
     left: 20px;
     background: rgba(26, 26, 26, 0.9);
     padding: 16px;
     border-radius: 12px;
     backdrop-filter: blur(10px);
     border-left: 4px solid #5de4c7;
     min-width: 200px;
   }
  
  .high-score-display h3 {
    margin: 0 0 12px 0;
    font-size: 14px;
    color: #5de4c7;
    text-align: center;
  }
  
  .high-score-item {
    display: flex;
    justify-content: space-between;
    margin: 6px 0;
    font-size: 12px;
  }
  
  .high-score-label {
    color: #8b90a7;
  }
  
  .high-score-value {
    color: #a6da95;
    font-weight: bold;
  }
  
  @media (max-width: 768px) {
    .mode-grid {
      grid-template-columns: 1fr;
      gap: 16px;
    }
    
    .mode-selector-content {
      padding: 20px;
      margin: 20px;
    }
    
         .high-score-display {
       position: relative;
       top: auto;
       left: auto;
       margin: 20px auto;
       max-width: 300px;
     }
  }
</style>
</head>
<body>
<div id="wrap">
     <div class="version">v1.8.4</div>
  <div class="debug" id="debug"></div>
  
  <!-- High Score Display -->
  <div class="high-score-display">
    <h3>üèÜ High Scores</h3>
    <div class="high-score-item">
      <span class="high-score-label">Basic:</span>
      <span class="high-score-value" id="basic-highscore-display">0</span>
    </div>
    <div class="high-score-item">
      <span class="high-score-label">Blocker:</span>
      <span class="high-score-value" id="blocker-highscore-display">0</span>
    </div>
    <div class="high-score-item">
      <span class="high-score-label">Multiplier:</span>
      <span class="high-score-value" id="multiplier-highscore-display">0</span>
    </div>
    <div class="high-score-item">
      <span class="high-score-label">Blast:</span>
      <span class="high-score-value" id="blast-highscore-display">0</span>
    </div>
  </div>
  
  <div class="header">
    <h1>Block Tetrist</h1>
    <div class="subtitle">Game ƒê·∫∑t Kh·ªëi Th√¥ng Minh - B√†n 8√ó8</div>
  </div>
  
    <canvas id="game" width="720" height="900"></canvas>
  
  <!-- Game Mode Selector Popup -->
  <div id="mode-selector" class="mode-selector">
    <div class="mode-selector-content">
      <h2>üéÆ Ch·ªçn Ch·∫ø ƒê·ªô Ch∆°i</h2>
      <div class="mode-grid">
        <button class="mode-button" data-mode="basic">
          <div class="mode-icon">üéØ</div>
          <div class="mode-title">Basic Mode</div>
          <div class="mode-desc">Chain multiplier c∆° b·∫£n</div>
          <div class="mode-highscore">High Score: <span id="basic-highscore">0</span></div>
        </button>
        <button class="mode-button" data-mode="blocker">
          <div class="mode-icon">üõ°Ô∏è</div>
          <div class="mode-title">Blocker Mode</div>
          <div class="mode-desc">Durable pieces + Precision bonus</div>
          <div class="mode-highscore">High Score: <span id="blocker-highscore">0</span></div>
        </button>
        <button class="mode-button" data-mode="multiplier">
          <div class="mode-icon">‚≠ê</div>
          <div class="mode-title">Multiplier Mode</div>
          <div class="mode-desc">Bonus points system</div>
          <div class="mode-highscore">High Score: <span id="multiplier-highscore">0</span></div>
        </button>
        <button class="mode-button" data-mode="blast">
          <div class="mode-icon">üí£</div>
          <div class="mode-title">Blast Mode</div>
          <div class="mode-desc">Bomb explosion system</div>
          <div class="mode-highscore">High Score: <span id="blast-highscore">0</span></div>
        </button>
      </div>
    </div>
  </div>
  
  <!-- Game Over Text Overlay -->
   <div id="game-over-overlay" class="game-over-text" style="display: none;">
     <div class="game-over-title">Thua R·ªìi!</div>
     <div class="game-over-stats">
       <div class="final-score">ƒêi·ªÉm: <span id="final-score">0</span></div>
       <div class="current-mode">Mode: <span id="current-mode-display">Basic</span></div>
     </div>
     <button class="game-over-button" onclick="resetGame()">Ch∆°i L·∫°i</button>
     <div class="other-modes">
       <div class="other-modes-title">Ch∆°i Mode Kh√°c:</div>
       <div class="other-modes-buttons">
         <button class="other-mode-btn" data-mode="basic">Basic</button>
         <button class="other-mode-btn" data-mode="blocker">Blocker</button>
         <button class="other-mode-btn" data-mode="multiplier">Multiplier</button>
         <button class="other-mode-btn" data-mode="blast">Blast</button>
       </div>
     </div>
   </div>
  
  <div class="stats-display">
    <div class="stat-item">
      <div class="stat-value" id="score-display">0</div>
      <div class="stat-label">ƒêi·ªÉm</div>
    </div>
    <div class="stat-item">
      <div class="stat-value" id="turn-display">0</div>
      <div class="stat-label">L∆∞·ª£t</div>
    </div>
    <div class="stat-item">
      <div class="stat-value" id="combo-display">1.0√ó</div>
      <div class="stat-label">Combo</div>
    </div>
    <div class="stat-item">
      <div class="stat-value" id="fr-display">0%</div>
      <div class="stat-label">Fill Rate</div>
    </div>
  </div>
  
  <div class="row">
    <div class="card legend">
      <h3>üéÆ C√°ch Ch∆°i</h3>
      <p><b>Ch·ªçn kh·ªëi</b> t·ª´ pool b√™n d∆∞·ªõi, sau ƒë√≥ <b>click l√™n √¥</b> tr√™n b√†n ƒë·ªÉ ƒë·∫∑t. <span class="hl">Chu·ªôt ph·∫£i</span> ƒë·ªÉ b·ªè ch·ªçn.</p>
      <p><span class="hl">Hold (H)</span>: L∆∞u 1 kh·ªëi (CD 3 l∆∞·ª£t)</p>
      <p><span class="hl">Swap (1/2/3)</span>: ƒê·ªïi kh·ªëi sang kh·ªëi c·ª©u n·∫°n (CD 9 l∆∞·ª£t)</p>
             <p><span class="hl">√î ƒë·ªè c√≥ s·ªë</span>: Piece c√≥ ƒë·ªô b·ªÅn, c·∫ßn x√≥a ƒë·ªß s·ªë l·∫ßn ƒë·ªÉ bi·∫øn m·∫•t</p>
             <p><span class="hl">√î bonus x2-x7</span>: Nh√¢n ƒëi·ªÉm khi clear line ch·ª©a √¥ bonus</p>
    </div>
    
    <div class="card legend">
      <h3>üèÜ H·ªá Th·ªëng ƒêi·ªÉm</h3>
      <p><b>Chain</b>: Clear li√™n ti·∫øp tƒÉng multiplier (‚â§1.5√ó)</p>
      <p><b>Precision</b>: Clear ‚â•2 line nh√¢n ƒëi·ªÉm (1.2√ó / 1.5√ó)</p>
      <p><b>Combo</b>: T√≠ch l≈©y theo th·ªùi gian</p>
      <p><b>Bonus Pieces</b>: √î x2-x7 nh√¢n ƒëi·ªÉm khi clear line</p>
      <p><b>Xoay kh·ªëi</b>: 32 lo·∫°i kh·ªëi v·ªõi 4 h∆∞·ªõng xoay kh√°c nhau</p>
    </div>
    
    <div class="card legend" id="msg"></div>
  </div>
  
  <div class="controls-info">
    <div class="control-group">
      <h3>‚å®Ô∏è ƒêi·ªÅu Khi·ªÉn</h3>
      <p><span class="key">H</span> - Hold kh·ªëi ƒëang ch·ªçn</p>
      <p><span class="key">1</span> - Swap kh·ªëi slot 1</p>
      <p><span class="key">2</span> - Swap kh·ªëi slot 2</p>
      <p><span class="key">3</span> - Swap kh·ªëi slot 3</p>
      <p><span class="key">Chu·ªôt ph·∫£i</span> - B·ªè ch·ªçn</p>
    </div>
    
    <div class="control-group">
      <h3>üéØ M·ª•c Ti√™u</h3>
      <p>ƒê·∫∑t kh·ªëi ƒë·ªÉ t·∫°o th√†nh h√†ng/c·ªôt ho√†n ch·ªânh</p>
      <p>Clear c√†ng nhi·ªÅu line c√†ng t·ªët</p>
      <p>Duy tr√¨ combo ƒë·ªÉ tƒÉng ƒëi·ªÉm</p>
      <p>Qu·∫£n l√Ω Fill Rate th√¥ng minh</p>
             <p>Clear c√°c √¥ c√≥ ƒë·ªô b·ªÅn (m√†u ƒë·ªè) ƒë·ªÉ tƒÉng ƒëi·ªÉm</p>
    </div>
    
    <div class="control-group">
      <h3>üéÅ H·ªá Th·ªëng Bonus</h3>
      <p>√î bonus x2-x7 xu·∫•t hi·ªán sau clear line (30% chance)</p>
      <p>Clear line ch·ª©a √¥ bonus ‚Üí nh√¢n ƒëi·ªÉm t∆∞∆°ng ·ª©ng</p>
      <p>Nhi·ªÅu √¥ bonus c√πng l√∫c ‚Üí nh√¢n d·ªìn (x2 √ó x5 = x10)</p>
      <p>√î bonus t·ª± bi·∫øn m·∫•t sau 2-4 l∆∞·ª£t</p>
    </div>
  </div>
</div>

<script>
(function(){
  const W = 720, H = 900;
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // Layout
  const BOARD_SIZE = 8;
  const CELL = 60; // cell px
  const BOARD_X = (W - CELL*BOARD_SIZE)/2; // center
  const BOARD_Y = 40;
  const POOL_Y = 620;

  // Tuning
  const scoring = {
    cell: 1,
    line: 10,
    precisionTwo: 1.2,
    precisionThree: 1.5,
    comboSteps: [1.0, 1.1, 1.3, 1.5],
    comboCap: 1.5
  };
  const holdCfg = { cdTurns: 3 };
  const swapCfg = { cdTurns: 9, rescueSet: ["1x2","1x2_90","1x3","1x3_90","I3","I3_90","L3","L3_90","L3_180","L3_270"] };
  const frWindow = { low: 0.30, high: 0.70 };
  const biasCfg = { base: 0.05, alpha: 0.20, betaJustDead: 0.10, cap: 0.25 };
  const guardrail = { windowRefills: 50, maxDead: 1 };

  // Game Mode System
  let currentGameMode = 'basic'; // 'basic', 'blocker', 'multiplier', 'blast'
  let gameStarted = false;
  
  // High Scores for each mode
  let highScores = {
    basic: parseInt(localStorage.getItem('blockTetristHighScore_basic')) || 0,
    blocker: parseInt(localStorage.getItem('blockTetristHighScore_blocker')) || 0,
    multiplier: parseInt(localStorage.getItem('blockTetristHighScore_multiplier')) || 0,
    blast: parseInt(localStorage.getItem('blockTetristHighScore_blast')) || 0
  };
  
  // State
  let grid = new Array(BOARD_SIZE).fill(0).map(()=>new Array(BOARD_SIZE).fill(0));
  let pool = [null, null, null]; // Initialize with null slots
  let score = 0;
  let comboLevel = 0;
  let selected = { from:"pool", index:-1, dx:0, dy:0 };
  let hold = { piece:null, cd:0 };
  let swapCD = 0;
  let recentDead = [];
  let justDead = false;
  let turn = 0;
  let highScore = highScores[currentGameMode]; // Current mode's high score
  let gameOver = false;
  let durablePieces = []; // Pieces with durability instead of blocked cells
  let comboTexts = [];
  let comboStreak = 0; // Combo streak counter for consecutive line clears
  let bonusPieces = []; // Bonus pieces with multipliers
  let bonusTexts = []; // Bonus score texts
  let bombPieces = []; // Bomb pieces that explode when lines are cleared
  let bombTexts = []; // Bomb explosion score texts
  let bombSpawned = false; // Track if bomb has been spawned this game

     // 71 pieces with rotations (v1.8.4)
   const PIECES = {
     // 1x1 - 1 direction (symmetric)
     "1x1":[[0,0]],
     
     // 1x2, 1x3, I3, I4, S4, Z4 - 2 directions (0¬∞, 90¬∞)
     "1x2":[[0,0],[0,1]], "1x2_90":[[0,0],[1,0]],
     "1x3":[[0,0],[0,1],[0,2]], "1x3_90":[[0,0],[1,0],[2,0]],
     "I3":[[0,0],[1,0],[2,0]], "I3_90":[[0,0],[0,1],[0,2]],
     "I4":[[0,0],[1,0],[2,0],[3,0]], "I4_90":[[0,0],[0,1],[0,2],[0,3]],
     "S4":[[0,1],[0,2],[1,0],[1,1]], "S4_90":[[0,0],[1,0],[1,1],[2,1]],
     "Z4":[[0,0],[0,1],[1,1],[1,2]], "Z4_90":[[0,1],[1,0],[1,1],[2,0]],
     
     // 2x2, O3 - 1 direction (symmetric)
     "2x2":[[0,0],[0,1],[1,0],[1,1]],
     "O3":[[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]],
     
     // L3, L4, T4 - 4 directions (0¬∞, 90¬∞, 180¬∞, 270¬∞)
     "L3":[[0,0],[1,0],[1,1]], "L3_90":[[0,0],[0,1],[1,0]], "L3_180":[[0,0],[0,1],[1,1]], "L3_270":[[0,1],[1,0],[1,1]],
     "L4":[[0,0],[1,0],[2,0],[2,1]], "L4_90":[[0,0],[0,1],[0,2],[1,0]], "L4_180":[[0,0],[0,1],[1,1],[2,1]], "L4_270":[[0,1],[1,1],[2,0],[2,1]],
     "T4":[[0,0],[0,1],[0,2],[1,1]], "T4_90":[[0,0],[1,0],[1,1],[2,0]], "T4_180":[[0,1],[1,0],[1,1],[1,2]], "T4_270":[[0,1],[1,0],[1,1],[2,1]],
     
     // New pieces from image - 4 directions each (0¬∞, 90¬∞, 180¬∞, 270¬∞)
     // Shape 1: 2x3 rectangle
     "R2x3":[[0,0],[0,1],[0,2],[1,0],[1,1],[1,2]], 
     "R2x3_90":[[0,0],[0,1],[1,0],[1,1],[2,0],[2,1]], 
     "R2x3_180":[[0,0],[0,1],[0,2],[1,0],[1,1],[1,2]], 
     "R2x3_270":[[0,0],[0,1],[1,0],[1,1],[2,0],[2,1]],
     
     // Shape 2: T rotated 90¬∞ clockwise (6 cells)
     "T6_90":[[0,0],[0,1],[0,2],[1,0],[1,1],[2,0]], 
     "T6_180":[[0,0],[1,0],[2,0],[2,1],[2,2],[1,2]], 
     "T6_270":[[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]], 
     "T6":[[0,1],[1,0],[1,1],[1,2],[2,1],[2,2]],
     
     // Shape 3: Inverted L
     "IL5":[[0,0],[1,0],[2,0],[3,0],[4,0],[0,1]], 
     "IL5_90":[[0,0],[0,1],[0,2],[0,3],[0,4],[1,4]], 
     "IL5_180":[[0,0],[0,1],[1,0],[2,0],[3,0],[4,0]], 
     "IL5_270":[[0,0],[0,1],[0,2],[0,3],[0,4],[1,0]],
     
     // Shape 4: 2x2 + left extension
     "L2x2":[[0,0],[0,1],[1,0],[1,1],[2,0]], 
     "L2x2_90":[[0,0],[0,1],[0,2],[1,0],[1,1]], 
     "L2x2_180":[[0,1],[1,0],[1,1],[2,0],[2,1]], 
     "L2x2_270":[[0,0],[0,1],[1,0],[1,1],[1,2]],
     
     // Shape 5: U shape (3x3 outline)
     "U3":[[0,0],[0,1],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]], 
     "U3_90":[[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]], 
     "U3_180":[[0,0],[0,1],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]], 
     "U3_270":[[0,0],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]],
     
     // Shape 6: 2x2 + right extension
     "R2x2R":[[0,0],[0,1],[1,0],[1,1],[0,2]], 
     "R2x2R_90":[[0,0],[0,1],[0,2],[1,0],[1,1]], 
     "R2x2R_180":[[0,0],[0,1],[1,0],[1,1],[1,2]], 
     "R2x2R_270":[[0,0],[0,1],[0,2],[1,0],[1,1]],
     
     // Shape 7: 2x2 + top-left extension
     "TL2x2":[[0,1],[0,2],[1,1],[1,2],[0,0]], 
     "TL2x2_90":[[0,0],[0,1],[1,0],[1,1],[2,0]], 
     "TL2x2_180":[[0,0],[0,1],[1,0],[1,1],[1,2]], 
     "TL2x2_270":[[0,0],[0,1],[0,2],[1,0],[1,1]],
     
     // Shape 8: 2x2 + bottom-right extension
     "BR2x2":[[0,0],[0,1],[1,0],[1,1],[2,2]], 
     "BR2x2_90":[[0,0],[0,1],[0,2],[1,0],[1,1]], 
     "BR2x2_180":[[0,0],[0,1],[1,0],[1,1],[2,0]], 
     "BR2x2_270":[[0,0],[0,1],[0,2],[1,0],[1,1]],
     
     // Shape 9: Cross shape (4 different rotations)
     "Cross":[[0,1],[1,0],[1,1],[1,2],[2,1]], 
     "Cross_90":[[1,0],[0,1],[1,1],[2,1],[1,2]], 
     "Cross_180":[[2,1],[1,0],[1,1],[1,2],[0,1]], 
     "Cross_270":[[1,2],[0,1],[1,1],[2,1],[1,0]],
     
     // Shape 10: T shape (4 cells) - different from existing T4
     "T4B":[[0,0],[0,1],[0,2],[1,1]], 
     "T4B_90":[[0,0],[1,0],[1,1],[2,0]], 
     "T4B_180":[[0,1],[1,0],[1,1],[1,2]], 
     "T4B_270":[[0,1],[1,0],[1,1],[2,1]],
     
     // Shape 11: 2x2 + top-right extension
     "TR2x2":[[0,0],[0,1],[1,0],[1,1],[0,2]], 
     "TR2x2_90":[[0,0],[0,1],[0,2],[1,0],[1,1]], 
     "TR2x2_180":[[0,0],[0,1],[1,0],[1,1],[1,2]], 
     "TR2x2_270":[[0,0],[0,1],[0,2],[1,0],[1,1]],
     
     // Shape 12: Vertical line + right extension
     "VL4R":[[0,0],[1,0],[2,0],[3,0],[2,1]], 
     "VL4R_90":[[0,0],[0,1],[0,2],[0,3],[1,3]], 
     "VL4R_180":[[0,1],[1,1],[2,1],[3,1],[2,0]], 
     "VL4R_270":[[0,0],[0,1],[0,2],[0,3],[1,0]]
   };
  
     // Piece colors for each rotation
   const PIECE_COLORS = {
     "1x1":"#ff6b6b", "1x2":"#51cf66", "1x3":"#339af0", "2x2":"#5de4c7",
     "I3":"#ffd43b", "I4":"#f783ac", "L3":"#4c6ef5", "L4":"#ae3ec9",
     "T4":"#ff6b6b", "S4":"#40c057", "Z4":"#e64980", "O3":"#ffa94d",
     
     // New pieces colors
     "R2x3":"#ff8787", "T6":"#ffa8a8", "IL5":"#ffc9c9", "L2x2":"#ffeb3b",
     "U3":"#ff9800", "R2x2R":"#4caf50", "TL2x2":"#8bc34a", "BR2x2":"#cddc39",
     "Cross":"#9c27b0", "TR2x2":"#673ab7", "VL4R":"#3f51b5", "T4B":"#ff5722",
     
     // Colors for rotated pieces (same as base)
     "1x2_90":"#51cf66", "1x3_90":"#339af0", "I3_90":"#ffd43b", "I4_90":"#f783ac",
     "S4_90":"#40c057", "Z4_90":"#e64980",
     "L3_90":"#4c6ef5", "L3_180":"#4c6ef5", "L3_270":"#4c6ef5",
     "L4_90":"#ae3ec9", "L4_180":"#ae3ec9", "L4_270":"#ae3ec9",
     "T4_90":"#ff6b6b", "T4_180":"#ff6b6b", "T4_270":"#ff6b6b",
     
     // New pieces rotated colors (same as base)
     "R2x3_90":"#ff8787", "R2x3_180":"#ff8787", "R2x3_270":"#ff8787",
     "T6_90":"#ffa8a8", "T6_180":"#ffa8a8", "T6_270":"#ffa8a8",
     "IL5_90":"#ffc9c9", "IL5_180":"#ffc9c9", "IL5_270":"#ffc9c9",
     "L2x2_90":"#ffeb3b", "L2x2_180":"#ffeb3b", "L2x2_270":"#ffeb3b",
     "U3_90":"#ff9800", "U3_180":"#ff9800", "U3_270":"#ff9800",
     "R2x2R_90":"#4caf50", "R2x2R_180":"#4caf50", "R2x2R_270":"#4caf50",
     "TL2x2_90":"#8bc34a", "TL2x2_180":"#8bc34a", "TL2x2_270":"#8bc34a",
     "BR2x2_90":"#cddc39", "BR2x2_180":"#cddc39", "BR2x2_270":"#cddc39",
     "Cross_90":"#9c27b0", "Cross_180":"#9c27b0", "Cross_270":"#9c27b0",
     "TR2x2_90":"#673ab7", "TR2x2_180":"#673ab7", "TR2x2_270":"#673ab7",
     "VL4R_90":"#3f51b5", "VL4R_180":"#3f51b5", "VL4R_270":"#3f51b5",
     "T4B_90":"#ff5722", "T4B_180":"#ff5722", "T4B_270":"#ff5722"
   };
  
     // Base weights for all 71 pieces
   const BASE_WEIGHTS = {
     "1x1":0.02, "1x2":0.05, "1x3":0.06, "2x2":0.07, "L3":0.06, "I4":0.07, "L4":0.07, "T4":0.06, "S4":0.06, "Z4":0.06, "O3":0.05, "I3":0.05,
     
     // New pieces weights
     "R2x3":0.06, "T6":0.05, "IL5":0.06, "L2x2":0.06, "U3":0.07, "R2x2R":0.06, "TL2x2":0.06, "BR2x2":0.06,
     "Cross":0.06, "TR2x2":0.06, "VL4R":0.06, "T4B":0.06,
     
     // Weights for rotated pieces (same as base)
     "1x2_90":0.05, "1x3_90":0.06, "I3_90":0.05, "I4_90":0.07, "S4_90":0.06, "Z4_90":0.06,
     "L3_90":0.06, "L3_180":0.06, "L3_270":0.06, "L4_90":0.07, "L4_180":0.07, "L4_270":0.07,
     "T4_90":0.06, "T4_180":0.06, "T4_270":0.06,
     
     // New pieces rotated weights (same as base)
     "R2x3_90":0.06, "R2x3_180":0.06, "R2x3_270":0.06,
     "T6_90":0.05, "T6_180":0.05, "T6_270":0.05,
     "IL5_90":0.06, "IL5_180":0.06, "IL5_270":0.06,
     "L2x2_90":0.06, "L2x2_180":0.06, "L2x2_270":0.06,
     "U3_90":0.07, "U3_180":0.07, "U3_270":0.07,
     "R2x2R_90":0.06, "R2x2R_180":0.06, "R2x2R_270":0.06,
     "TL2x2_90":0.06, "TL2x2_180":0.06, "TL2x2_270":0.06,
     "BR2x2_90":0.06, "BR2x2_180":0.06, "BR2x2_270":0.06,
     "Cross_90":0.06, "Cross_180":0.06, "Cross_270":0.06,
     "TR2x2_90":0.06, "TR2x2_180":0.06, "TR2x2_270":0.06,
     "VL4R_90":0.06, "VL4R_180":0.06, "VL4R_270":0.06,
     "T4B_90":0.06, "T4B_180":0.06, "T4B_270":0.06
   };

  function rnd(){ return Math.random(); }
  function clone(obj){ return JSON.parse(JSON.stringify(obj)); }
  function msg(t){ document.getElementById('msg').innerHTML = t; }
  function debug(t){ document.getElementById('debug').innerHTML = t; }
  
  // Game Mode Management Functions
  function selectGameMode(mode) {
    currentGameMode = mode;
    highScore = highScores[mode];
    gameStarted = true;
    
    // Hide mode selector
    document.getElementById('mode-selector').style.display = 'none';
    
    // Reset game for new mode
    resetGame();
    
    // Update high score display
    updateHighScoreDisplay();
    
    console.log(`Game mode selected: ${mode}`);
  }
  
  function updateHighScoreDisplay() {
    // Update mode selector high scores
    document.getElementById('basic-highscore').textContent = highScores.basic;
    document.getElementById('blocker-highscore').textContent = highScores.blocker;
    document.getElementById('multiplier-highscore').textContent = highScores.multiplier;
    document.getElementById('blast-highscore').textContent = highScores.blast;
    
    // Update right panel high scores
    document.getElementById('basic-highscore-display').textContent = highScores.basic;
    document.getElementById('blocker-highscore-display').textContent = highScores.blocker;
    document.getElementById('multiplier-highscore-display').textContent = highScores.multiplier;
    document.getElementById('blast-highscore-display').textContent = highScores.blast;
  }
  
  function saveHighScore(mode, score) {
    if (score > highScores[mode]) {
      highScores[mode] = score;
      localStorage.setItem(`blockTetristHighScore_${mode}`, score.toString());
      console.log(`New high score for ${mode} mode: ${score}`);
      return true;
    }
    return false;
  }
  
  function showModeSelector() {
    document.getElementById('mode-selector').style.display = 'flex';
    gameStarted = false;
  }
  
  function getModeDisplayName(mode) {
    const modeNames = {
      'basic': 'Basic Mode',
      'blocker': 'Blocker Mode', 
      'multiplier': 'Multiplier Mode',
      'blast': 'Blast Mode'
    };
    return modeNames[mode] || mode;
  }

  function updateStats() {
    document.getElementById('score-display').textContent = score;
    document.getElementById('turn-display').textContent = turn;
    document.getElementById('combo-display').textContent = Math.min(scoring.comboSteps[comboLevel], scoring.comboCap).toFixed(1) + '√ó';
    document.getElementById('fr-display').textContent = Math.round(getFillRate() * 100) + '%';
    
    // Update high score for current mode
    if (score > highScore) {
      highScore = score;
      saveHighScore(currentGameMode, score);
    }
  }
  
  function checkGameOver() {
    // Check if there are any empty cells on the board
    let hasEmptyCells = false;
    for(let r = 0; r < BOARD_SIZE; r++) {
      for(let c = 0; c < BOARD_SIZE; c++) {
        if(!grid[r][c] && !isDurablePiece(r, c)) {
          hasEmptyCells = true;
          break;
        }
      }
      if(hasEmptyCells) break;
    }
    
    // If no empty cells, game is over (victory condition)
    if(!hasEmptyCells) return true;
    
    // Check if any piece in pool can be placed anywhere
    for(let i = 0; i < pool.length; i++) {
      if(pool[i] !== null) {
        // If this piece can be placed anywhere, game continues
        if(validPlacementsAny(pool[i])) return false;
      }
    }
    
    // If pool is empty, game is NOT over - just need to refill
    if(pool.every(p => p === null)) return false;
    
    // If we reach here, pool has pieces but none can be placed
    // Game over - player cannot place any remaining pieces
    return true;
  }
  
  function resetGame() {
    grid = new Array(BOARD_SIZE).fill(0).map(()=>new Array(BOARD_SIZE).fill(0));
    pool = [null, null, null];
    score = 0;
    comboLevel = 0;
    selected = { from:"pool", index:-1, dx:0, dy:0 };
    hold = { piece:null, cd:0 };
    swapCD = 0;
    recentDead = [];
    justDead = false;
    turn = 0;
    gameOver = false;
    comboTexts = [];
    comboStreak = 0;
    bonusPieces = [];
    bonusTexts = [];
    bombPieces = [];
    bombTexts = [];
    bombSpawned = false;
    
    // Generate features based on game mode
    if (currentGameMode === 'blocker') {
      generateDurablePieces();
    }
    
    refillPool();
    render();
  }
  
  // Make resetGame globally accessible
  window.resetGame = resetGame;
  
  function addComboText(text, x, y) {
    const comboText = {
      text: text,
      x: x,
      y: y,
      startTime: Date.now(),
      id: Math.random()
    };
    comboTexts.push(comboText);
    
    // Remove after animation
    setTimeout(() => {
      comboTexts = comboTexts.filter(ct => ct.id !== comboText.id);
    }, 2000);
  }
  
  function drawComboTexts() {
    const currentTime = Date.now();
    comboTexts.forEach(ct => {
      let elapsed = currentTime - ct.startTime;
      let progress = elapsed / 2000; // 2 seconds total
      
      if(progress < 1) {
        ctx.save();
        ctx.globalAlpha = 1 - progress;
        ctx.font = "48px system-ui";
        ctx.fillStyle = "#5de4c7";
        ctx.textAlign = "center";
        ctx.fillText(ct.text, ct.x, ct.y - progress * 40);
        ctx.restore();
      }
    });
  }

  function normalize(weights){
    let s=0; for (const k in weights) s+=weights[k];
    const out={}; for (const k in weights) out[k]=weights[k]/s;
    return out;
  }
  function applyBias(base, keys, factor){
    const out = {...base};
    for(const k of keys){ if(out[k]!=null) out[k]*=(1+factor); }
    return normalize(out);
  }
  function sampleOne(weights){
    const r = rnd(); let acc=0, last=null;
    for(const k in weights){ acc+=weights[k]; last=k; if(r<=acc) return makePiece(k); }
    return makePiece(last);
  }
  function sampleThree(weights){ return [sampleOne(weights), sampleOne(weights), sampleOne(weights)]; }
  function makePiece(key){ 
    return { 
      id: key, 
      cells: PIECES[key].map(p=>({r:p[0], c:p[1]})),
      color: PIECE_COLORS[key] || "#9aa5ff"
    }; 
  }

  function getFillRate(){
  let filled=0;
  for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++) {
    if(grid[r][c] || isDurablePiece(r,c) || isBonusPiece(r,c)) filled++;
    // Only count bomb pieces in Blast Mode
    if(currentGameMode === 'blast' && isBombPiece(r,c)) filled++;
  }
  return filled/(BOARD_SIZE*BOARD_SIZE);
}
  
  function isDurablePiece(r, c) {
    return durablePieces.some(piece => piece.r === r && piece.c === c);
  }
  
  function getDurablePiece(r, c) {
    return durablePieces.find(piece => piece.r === r && piece.c === c);
  }
  
  function generateDurablePieces() {
    let count = Math.floor(Math.random() * 7) + 6; // 6-12 pieces
    durablePieces = [];
    for(let i = 0; i < count; i++) {
      let r, c;
      do {
        r = Math.floor(Math.random() * BOARD_SIZE);
        c = Math.floor(Math.random() * BOARD_SIZE);
      } while(isDurablePiece(r, c) || (r === 0 && c === 0)); // Avoid top-left corner
      
      // Random durability 2-5
      let durability = Math.floor(Math.random() * 4) + 2;
      durablePieces.push({
        r: r, 
        c: c, 
        durability: durability,
        color: "#ff6b6b"
      });
    }
  }
  
  function generateBonusPieces() {
    // 30% chance to spawn bonus pieces after line clear
    if (Math.random() > 0.3) {
      console.log("Bonus spawn failed: 30% chance not met");
      return;
    }
    
    // Don't spawn if already at max (4 pieces)
    if (bonusPieces.length >= 4) {
      console.log("Bonus spawn failed: Already at max (4 pieces)");
      return;
    }
    
    // Find positions on EXISTING pieces (not empty cells) to place bonus on
    let availablePositions = [];
    for(let r = 0; r < BOARD_SIZE; r++) {
      for(let c = 0; c < BOARD_SIZE; c++) {
        // Only spawn on cells that have pieces (grid[r][c] = 1) or durable pieces
        if((grid[r][c] || isDurablePiece(r, c)) && !isBonusPiece(r, c)) {
          availablePositions.push({r: r, c: c});
        }
      }
    }
    
    if(availablePositions.length === 0) {
      console.log("Bonus spawn failed: No available positions on existing pieces");
      return;
    }
    
    console.log(`Bonus spawn: Found ${availablePositions.length} available positions on existing pieces`);
    
    // Spawn 2-3 bonus pieces
    let spawnCount = Math.floor(Math.random() * 2) + 2; // 2-3 pieces
    spawnCount = Math.min(spawnCount, 4 - bonusPieces.length, availablePositions.length);
    
    console.log(`Bonus spawn: Attempting to spawn ${spawnCount} pieces`);
    
    for(let i = 0; i < spawnCount; i++) {
      let posIndex = Math.floor(Math.random() * availablePositions.length);
      let pos = availablePositions.splice(posIndex, 1)[0];
      
      // Random multiplier: x2, x3, x4, x5, x6, x7
      let multipliers = [2, 3, 4, 5, 6, 7];
      let multiplier = multipliers[Math.floor(Math.random() * multipliers.length)];
      
      // Determine lifetime based on multiplier
      let lifetime;
      if(multiplier <= 3) lifetime = 4;      // x2, x3: 4 turns
      else if(multiplier <= 5) lifetime = 3; // x4, x5: 3 turns
      else lifetime = 2;                      // x6, x7: 2 turns
      
      bonusPieces.push({
        r: pos.r,
        c: pos.c,
        multiplier: multiplier,
        lifetime: lifetime,
        color: getBonusColor(multiplier)
      });
      
      console.log(`Bonus piece spawned: x${multiplier} at (${pos.r}, ${pos.c}) with ${lifetime} turns lifetime`);
    }
    
    console.log(`Total bonus pieces after spawn: ${bonusPieces.length}`);
  }
  
  function getBonusColor(multiplier) {
    // Color coding for different multipliers
    if(multiplier <= 3) return "#51cf66";      // Green for x2, x3
    else if(multiplier <= 5) return "#ffd43b"; // Yellow for x4, x5
    else return "#ff6b6b";                      // Red for x6, x7
  }
  
  function isBonusPiece(r, c) {
    return bonusPieces.some(piece => piece.r === r && piece.c === c);
  }
  
  function getBonusPiece(r, c) {
  return bonusPieces.find(piece => piece.r === r && piece.c === c);
}

function isBombPiece(r, c) {
  return bombPieces.some(piece => piece.r === r && piece.c === c);
}

function getBombPiece(r, c) {
  return bombPieces.find(piece => piece.r === r && piece.c === c);
}
  
  function addBonusText(text, x, y) {
  const bonusText = {
    text: text,
    x: x,
    y: y,
    startTime: Date.now(),
    id: Math.random()
  };
  bonusTexts.push(bonusText);
  
  // Remove after 2 seconds
  setTimeout(() => {
    bonusTexts = bonusTexts.filter(bt => bt.id !== bonusText.id);
  }, 2000);
}

function addBombText(text, x, y) {
  const bombText = {
    text: text,
    x: x,
    y: y,
    startTime: Date.now(),
    id: Math.random()
  };
  bombTexts.push(bombText);
  
  // Remove after 2 seconds
  setTimeout(() => {
    bombTexts = bombTexts.filter(bt => bt.id !== bombText.id);
  }, 2000);
}
  
  function drawBonusTexts() {
  const currentTime = Date.now();
  bonusTexts.forEach(bt => {
    let elapsed = currentTime - bt.startTime;
    let progress = elapsed / 2000; // 2 seconds total
    
    if(progress < 1) {
      ctx.save();
      ctx.globalAlpha = 1 - progress;
      ctx.font = "bold 32px system-ui";
      ctx.fillStyle = "#5de4c7";
      ctx.textAlign = "center";
      ctx.fillText(bt.text, bt.x, bt.y - progress * 30);
      ctx.restore();
    }
  });
}

function drawBombTexts() {
  const currentTime = Date.now();
  bombTexts.forEach(bt => {
    let elapsed = currentTime - bt.startTime;
    let progress = elapsed / 2000; // 2 seconds total
    
    if(progress < 1) {
      ctx.save();
      ctx.globalAlpha = 1 - progress;
      ctx.font = "bold 32px system-ui";
      ctx.fillStyle = "#ff6b6b";
      ctx.textAlign = "center";
      ctx.fillText(bt.text, bt.x, bt.y - progress * 30);
      ctx.restore();
    }
  });
}
  function canPlace(piece, R, C){
  for(const cell of piece.cells){
    let rr=R+cell.r, cc=C+cell.c;
    if(rr<0||rr>=BOARD_SIZE||cc<0||cc>=BOARD_SIZE) return false;
    if(grid[rr][cc] || isDurablePiece(rr, cc) || isBonusPiece(rr, cc)) return false;
    // Only check bomb pieces in Blast Mode
    if(currentGameMode === 'blast' && isBombPiece(rr, cc)) return false;
  }
  return true;
}
  function validPlacementsAny(p){
    for(let r=0;r<BOARD_SIZE;r++) for(let c=0;c<BOARD_SIZE;c++) if(canPlace(p, r, c)) return true;
    return false;
  }
  function placePiece(piece, R, C){
    let placed=0;
    for(const cell of piece.cells){ let rr=R+cell.r, cc=C+cell.c; grid[rr][cc]=1; placed++; }
    return placed;
  }
  function clearLines(){
    const clearedRows=[], clearedCols=[];
              for(let r=0;r<BOARD_SIZE;r++){ 
       let full=true; 
       for(let c=0;c<BOARD_SIZE;c++){ 
         // A line is full if it has pieces OR durable pieces OR bonus pieces (and bomb pieces only in Blast Mode)
         if(!grid[r][c] && !isDurablePiece(r,c) && !isBonusPiece(r,c)) {
           // Only check bomb pieces in Blast Mode
           if(currentGameMode === 'blast' && !isBombPiece(r,c)) {
             full=false;
             break;
           } else if(currentGameMode !== 'blast') {
             full=false;
             break;
           }
         }
       } 
       if(full) clearedRows.push(r); 
     }
     for(let c=0;c<BOARD_SIZE;c++){ 
       let full=true; 
       for(let r=0;r<BOARD_SIZE;r++){ 
         // A line is full if it has pieces OR durable pieces OR bonus pieces (and bomb pieces only in Blast Mode)
         if(!grid[r][c] && !isDurablePiece(r,c) && !isBonusPiece(r,c)) {
           // Only check bomb pieces in Blast Mode
           if(currentGameMode === 'blast' && !isBombPiece(r,c)) {
             full=false;
             break;
           } else if(currentGameMode !== 'blast') {
             full=false;
             break;
           }
         }
       } 
       if(full) clearedCols.push(c); 
     }
    
    // Check for cross clear bonus
    let crossBonus = 0;
    if(clearedRows.length > 0 && clearedCols.length > 0) {
      // Cross clear detected!
      let crossSize = clearedRows.length * clearedCols.length;
      if(crossSize === 1) crossBonus = 3;        // 1x1 cross: -3 durability
      else if(crossSize === 2) crossBonus = 4;   // 2x1 or 1x2 cross: -4 durability
      else if(crossSize === 4) crossBonus = 6;   // 2x2 cross: -6 durability
      else if(crossSize >= 6) crossBonus = 999;  // 2x3 or 3x2+ cross: clear all!
    }
    
    // Calculate bonus multipliers for cleared lines BEFORE clearing
    let totalBonusMultiplier = 1;
    let clearedBonusPieces = [];
    
    console.log(`Checking for bonus pieces in ${clearedRows.length} rows and ${clearedCols.length} columns`);
    
    // Check rows for bonus pieces
    for(let rr of clearedRows) {
      for(let c = 0; c < BOARD_SIZE; c++) {
        let bonusPiece = getBonusPiece(rr, c);
        if(bonusPiece) {
          console.log(`Found bonus piece x${bonusPiece.multiplier} in cleared row ${rr} at column ${c}`);
          totalBonusMultiplier *= bonusPiece.multiplier;
          clearedBonusPieces.push(bonusPiece);
        }
      }
    }
    
    // Check columns for bonus pieces
    for(let cc of clearedCols) {
      for(let r = 0; r < BOARD_SIZE; r++) {
        let bonusPiece = getBonusPiece(r, cc);
        if(bonusPiece) {
          console.log(`Found bonus piece x${bonusPiece.multiplier} in cleared column ${cc} at row ${r}`);
          totalBonusMultiplier *= bonusPiece.multiplier;
          clearedBonusPieces.push(bonusPiece);
        }
      }
    }
    
    console.log(`Total bonus multiplier: ${totalBonusMultiplier}, Cleared ${clearedBonusPieces.length} bonus pieces`);
    
    // Clear rows and columns, including durable pieces and bonus pieces
    // Track which pieces have been affected by cross bonus to avoid double-counting
    let affectedPieces = new Set();
    
    for(let rr of clearedRows){ 
      for(let c=0;c<BOARD_SIZE;c++) { 
        grid[rr][c]=0; 
        // Reduce durability of durable pieces in cleared rows
        let piece = getDurablePiece(rr, c);
        if(piece) {
          if(crossBonus >= 999) {
            piece.durability = 0; // Clear all for large cross
          } else {
            // For cross clear, only apply bonus once per piece
            if(affectedPieces.has(piece)) {
              piece.durability = Math.max(0, piece.durability - 1); // Normal line clear
            } else {
              piece.durability = Math.max(0, piece.durability - 1 - crossBonus); // First hit with bonus
              affectedPieces.add(piece);
            }
          }
        }
      } 
    }
    for(let cc of clearedCols){ 
      for(let r=0;r<BOARD_SIZE;r++) { 
        grid[r][cc]=0; 
        // Reduce durability of durable pieces in cleared columns
        let piece = getDurablePiece(r, cc);
        if(piece) {
          if(crossBonus >= 999) {
            piece.durability = 0; // Clear all for large cross
          } else {
            // For cross clear, only apply bonus once per piece
            if(affectedPieces.has(piece)) {
              piece.durability = Math.max(0, piece.durability - 1); // Normal line clear
            } else {
              piece.durability = Math.max(0, piece.durability - 1 - crossBonus); // First hit with bonus
              affectedPieces.add(piece);
            }
          }
        }
      } 
    }
    
    // Remove pieces with 0 durability
    durablePieces = durablePieces.filter(piece => piece.durability > 0);
    
    // Generate new bonus pieces after line clear (BEFORE removing cleared ones) - Only for Multiplier Mode
    if((clearedRows.length > 0 || clearedCols.length > 0) && currentGameMode === 'multiplier') {
      console.log(`Line clear detected: ${clearedRows.length} rows, ${clearedCols.length} cols`);
      console.log(`Bonus pieces before spawn: ${bonusPieces.length}`);
      generateBonusPieces();
      console.log(`Bonus pieces after spawn: ${bonusPieces.length}`);
    }
    
         // Remove cleared bonus pieces from the bonusPieces array (AFTER spawning new ones)
     bonusPieces = bonusPieces.filter(piece => 
       !clearedBonusPieces.some(cleared => cleared.r === piece.r && cleared.c === piece.c)
     );

           // Check for bombs in cleared lines and explode them - Only for Blast Mode
      let clearedBombs = [];
      if (currentGameMode === 'blast') {
        for(let rr of clearedRows) {
          for(let c = 0; c < BOARD_SIZE; c++) {
            if(isBombPiece(rr, c)) {
              clearedBombs.push({r: rr, c: c});
            }
          }
        }
        for(let cc of clearedCols) {
          for(let r = 0; r < BOARD_SIZE; r++) {
            if(isBombPiece(r, cc)) {
              clearedBombs.push({r: r, c: cc});
            }
          }
        }
      }
     
     // Explode bombs that are in cleared lines - Only for Blast Mode
     if (currentGameMode === 'blast') {
       for(let bomb of clearedBombs) {
         explodeBomb(bomb.r, bomb.c);
       }
     }

     // Try to generate bomb piece if conditions are met - Only for Blast Mode
     // Generate new bomb after line clear (allowing multiple bombs per game)
     if (currentGameMode === 'blast') {
       generateBombPiece();
     }
    
    return {
      rows: clearedRows, 
      cols: clearedCols, 
      crossBonus: crossBonus,
      bonusMultiplier: totalBonusMultiplier,
      clearedBonusPieces: clearedBonusPieces
    };
  }

  function getBiasFactor(FR){
    let f = biasCfg.base;
    if(FR > frWindow.high) f += biasCfg.alpha*(FR - frWindow.high);
    if(justDead) f += biasCfg.betaJustDead;
    return Math.min(f, biasCfg.cap);
  }

  function refillPool(){
    let FR = getFillRate();
    let weights = normalize(BASE_WEIGHTS);
    let factor = getBiasFactor(FR);
    weights = applyBias(weights, swapCfg.rescueSet, factor);
    
    // Always ensure we have 3 pieces - refill all null slots
    let refilledCount = 0;
    for(let i = 0; i < pool.length; i++) {
      if(pool[i] === null) {
        pool[i] = sampleOne(weights);
        refilledCount++;
      }
    }
    
    // Double check - if any slot is still null, fill it
    for(let i = 0; i < pool.length; i++) {
      if(pool[i] === null) {
        pool[i] = sampleOne(weights);
        refilledCount++;
      }
    }
    
    // Log refill info (hidden)
    // console.log(`Refilled ${refilledCount} slots. Pool now has:`, pool.map(p => p ? p.id : 'null'));
    // console.log('Pool array:', pool);
    // console.log('Pool length:', pool.length);
    // console.log('Pool null count:', pool.filter(p => p === null).length);
    
    let placeable = pool.some(pc => pc && validPlacementsAny(pc));

    if(!placeable){
      // Repair step 1: replace one with rescue
      let idx = Math.floor(rnd()*3);
      let rk = swapCfg.rescueSet[Math.floor(rnd()*swapCfg.rescueSet.length)];
      pool[idx] = makePiece(rk);
      placeable = pool.some(pc => pc && validPlacementsAny(pc));
      // Repair step 2: resample once if still dead
      if(!placeable){
        pool[idx] = sampleOne(weights);
        placeable = pool.some(pc => pc && validPlacementsAny(pc));
      }
    }

    // Update DSR window + guardrail
    recentDead.push(placeable?0:1); if(recentDead.length>guardrail.windowRefills) recentDead.shift();
    justDead = !placeable;
          if(!placeable){
        let sum = recentDead.reduce((a,b)=>a+b,0);
        if(sum >= guardrail.maxDead){
        // Force fix again
        let idx = Math.floor(rnd()*3);
        let rk = swapCfg.rescueSet[Math.floor(rnd()*swapCfg.rescueSet.length)];
        pool[idx] = makePiece(rk);
        placeable = pool.some(pc => pc && validPlacementsAny(pc));
        recentDead[recentDead.length-1] = placeable?0:1; // update last flag
        justDead = !placeable;
      }
    }

    comboLevel = 0; // reset combo at refill start
    comboStreak = 0; // reset combo streak at refill start
    
    // Try to generate bomb piece if conditions are met - Only for Blast Mode
    // Generate new bomb during pool refill (allowing multiple bombs per game)
    if (currentGameMode === 'blast') {
      generateBombPiece();
    }
    
         // Debug info
     debug(`Mode: ${currentGameMode.toUpperCase()}<br/>Pool: ${pool.filter(p => p !== null).length}/3 items<br/>Hold: ${hold.piece?'Yes':'No'} (CD:${hold.cd})<br/>Swap: CD ${swapCD}<br/>Pool state: [${pool.map(p => p ? p.id : 'null').join(', ')}]<br/>Pool array length: ${pool.length}<br/>Bonus: ${bonusPieces.length}/4 pieces<br/>Bomb: ${bombPieces.length} pieces<br/>Total Pieces: 71`);
    
    render();
  }

  function decreaseBonusLifetimes() {
    console.log(`Decreasing bonus lifetimes. Before: ${bonusPieces.length} pieces`);
    bonusPieces.forEach(piece => {
      piece.lifetime--;
      console.log(`Bonus piece x${piece.multiplier} at (${piece.r}, ${piece.c}) lifetime: ${piece.lifetime + 1} -> ${piece.lifetime}`);
    });
    let beforeCount = bonusPieces.length;
    bonusPieces = bonusPieces.filter(piece => piece.lifetime > 0);
    let afterCount = bonusPieces.length;
    if(beforeCount !== afterCount) {
      console.log(`Removed ${beforeCount - afterCount} expired bonus pieces. Remaining: ${afterCount}`);
    }
  }
  
  // Input mapping
  function gridAt(x,y){
    let gx = Math.floor((x-BOARD_X)/CELL);
    let gy = Math.floor((y-BOARD_Y)/CELL);
    if(gx>=0&&gx<BOARD_SIZE&&gy>=0&&gy<BOARD_SIZE) return {c:gx,r:gy};
    return null;
  }
  function poolSlotAt(x,y){
    // Three slots centered
    let gap = 12, box = 140;
    let totalW = box*3 + gap*2;
    let left = (W-totalW)/2;
    let top = POOL_Y;
    for(let i=0;i<3;i++){
      let rx=left + i*(box+gap), ry=top;
      if(x>=rx && x<=rx+box && y>=ry && y<=ry+box) return i;
    }
    return -1;
  }

  canvas.addEventListener('contextmenu', e=>e.preventDefault());
  canvas.addEventListener('mousedown', (e)=>{
    let rect=canvas.getBoundingClientRect();
    let x=e.clientX-rect.left, y=e.clientY-rect.top;
    if(e.button===2){ selected.index=-1; render(); return; }

    // If clicking pool slot -> select piece
          let slot = poolSlotAt(x,y);
      if(slot>=0 && pool[slot] !== null){
      selected = { from:"pool", index:slot, dx:0, dy:0 };
      render(); return;
    }

    // If have selection, try placing on board
    if(selected.index>=0){
      let g = gridAt(x,y);
      if(g){
        let piece = pool[selected.index];
        if(canPlace(piece, g.r, g.c)){
                     let placedCells = placePiece(piece, g.r, g.c);
           let cleared = clearLines();
           
           // scoring
           const lines = cleared.rows.length + cleared.cols.length;
           let baseScore = placedCells*scoring.cell + lines*scoring.line;
           
           // Apply bonus multiplier if any bonus pieces were cleared
           if(cleared.bonusMultiplier > 1) {
             let bonusScore = baseScore * (cleared.bonusMultiplier - 1);
             score += baseScore + bonusScore;
             
             // Display bonus score text
             let centerX = BOARD_X + (BOARD_SIZE * CELL) / 2;
             let centerY = BOARD_Y + (BOARD_SIZE * CELL) / 2;
             addBonusText(`+${bonusScore}`, centerX, centerY + 120);
           } else {
             score += baseScore;
           }
           
           // Precision bonus only for Blocker Mode
           if (currentGameMode === 'blocker') {
             if(lines>=3) score = Math.floor(score*scoring.precisionThree);
             else if(lines>=2) score = Math.floor(score*scoring.precisionTwo);
           }
           
           // combo
           if(lines>0) comboLevel = Math.min(comboLevel+1, scoring.comboSteps.length-1);
           else comboLevel = 0;
           score = Math.floor(score * Math.min(scoring.comboSteps[comboLevel], scoring.comboCap));
           
           // Add combo text based on consecutive streak (v1.4.3)
           if(lines > 0) {
             comboStreak++; // Increment streak for each line clear
             let centerX = BOARD_X + (BOARD_SIZE * CELL) / 2;
             let centerY = BOARD_Y + (BOARD_SIZE * CELL) / 2;
             
             // Combo text based on streak (max 10)
             let comboText = "Good";
             if(comboStreak >= 10) comboText = "Ultimate!";
             else if(comboStreak >= 9) comboText = "Godlike!";
             else if(comboStreak >= 8) comboText = "Legendary!";
             else if(comboStreak >= 7) comboText = "Unbelievable!";
             else if(comboStreak >= 6) comboText = "Incredible!";
             else if(comboStreak >= 5) comboText = "Fantastic!";
             else if(comboStreak >= 4) comboText = "Amazing!";
             else if(comboStreak >= 3) comboText = "Great!";
             else if(comboStreak >= 2) comboText = "Nice!";
             
             // Add cross bonus text if applicable
             if(cleared.crossBonus > 0) {
               let bonusText = "";
               if(cleared.crossBonus >= 999) bonusText = "CLEAR ALL!";
               else if(cleared.crossBonus >= 6) bonusText = "MEGA CROSS!";
               else if(cleared.crossBonus >= 4) bonusText = "BIG CROSS!";
               else if(cleared.crossBonus >= 3) bonusText = "CROSS!";
               
               if(bonusText) {
                 addComboText(bonusText, centerX, centerY + 60);
               }
             }
             
             addComboText(comboText, centerX, centerY);
           } else {
             // Reset streak if no lines cleared
             comboStreak = 0;
           }

           // consume piece
           pool[selected.index] = null;
           selected.index=-1;
           turn++;
           if(swapCD>0) swapCD--;
           if(hold.cd>0) hold.cd--;
           
                       // Decrease bonus piece lifetimes
            decreaseBonusLifetimes();
            
            // Decrease bomb lifetimes - Only for Blast Mode
            if (currentGameMode === 'blast') {
              decreaseBombLifetimes();
            }

           // Render FIRST to show the placed piece AND cleared lines
           render();
           
           // THEN check for game over (after lines have been cleared)
           if(checkGameOver()) {
             gameOver = true;
             render();
             return;
           }
           
           // Auto refill pool if it's empty
           if(pool.every(p => p === null)) {
             refillPool();
             return;
           }
        }
      }
    }

    // If click on hold area to release (simple: if pool has <3, push back)
    let holdRect = {x:40, y:POOL_Y+160, w:180, h:80};
    if(x>=holdRect.x && x<=holdRect.x+holdRect.w && y>=holdRect.y && y<=holdRect.y+holdRect.h){
      if(hold.piece){
        // Find first empty slot
        let emptySlot = pool.findIndex(p => p === null);
        if(emptySlot !== -1) {
          pool[emptySlot] = hold.piece;
          hold.piece = null;
          render();
          return;
        }
      }
    }
  });

  // UI buttons via keys for simplicity
  window.addEventListener('keydown', (e)=>{
    if(e.key==='h' || e.key==='H'){
      // Hold selected piece - ch·ªâ khi c√≥ kh·ªëi ƒë∆∞·ª£c ch·ªçn v√† hold slot tr·ªëng
      if(selected.index>=0 && !hold.piece && hold.cd<=0){
        hold.piece = pool[selected.index];
        pool[selected.index] = null;
        hold.cd = holdCfg.cdTurns;
        selected.index=-1;
        
        // Auto refill if pool is empty
        if(pool.every(p => p === null)) {
          refillPool();
        } else {
          render();
        }
      }
    } else if(e.key==='1' || e.key==='2' || e.key==='3'){
      // Swap piece index 0/1/2 - ch·ªâ khi swapCD = 0
      let idx = parseInt(e.key,10)-1;
      if(idx>=0 && idx<pool.length){
        if(swapCD<=0){
          let rk = swapCfg.rescueSet[Math.floor(rnd()*swapCfg.rescueSet.length)];
          pool[idx] = makePiece(rk);
          swapCD = swapCfg.cdTurns;
          
          // Check for game over after swap
          if(checkGameOver()) {
            gameOver = true;
          }
          render();
        }
      }
    }
  });

  function drawBoard(){
    // Debug: Log bonus pieces state
    if(bonusPieces.length > 0) {
      console.log(`Drawing ${bonusPieces.length} bonus pieces:`, bonusPieces);
    }
    
    // grid
    for(let r=0;r<BOARD_SIZE;r++){
      for(let c=0;c<BOARD_SIZE;c++){
        let x = BOARD_X + c*CELL, y = BOARD_Y + r*CELL;
        
        if(isDurablePiece(r, c)) {
          // Draw durable piece with durability number
          let piece = getDurablePiece(r, c);
          let durability = piece.durability;
          
          // Color based on durability (darker = higher durability)
          let intensity = Math.max(0.3, durability / 5);
          ctx.fillStyle = `rgba(247, 118, 142, ${intensity})`;
          ctx.fillRect(x+2,y+2,CELL-4,CELL-4);
          ctx.strokeStyle = "#d73a49";
          ctx.lineWidth = 2;
          ctx.strokeRect(x+2, y+2, CELL-4, CELL-4);
          
          // Draw durability number
          ctx.fillStyle = "#ffffff";
          ctx.font = "bold 16px system-ui";
          ctx.textAlign = "center";
          ctx.fillText(durability.toString(), x + CELL/2, y + CELL/2 + 5);
                 } else if(currentGameMode === 'blast' && isBombPiece(r, c)) {
           // Draw bomb piece with distinct black color and red border - Only for Blast Mode
           let piece = getBombPiece(r, c);
           let lifetime = piece.lifetime;
           
           // Black background with red border
           ctx.fillStyle = "#000000";
           ctx.fillRect(x+2,y+2,CELL-4,CELL-4);
           ctx.strokeStyle = "#ff0000";
           ctx.lineWidth = 3;
           ctx.strokeRect(x+2, y+2, CELL-4, CELL-4);
           
           // Draw "BOMB" text
           ctx.fillStyle = "#ffffff";
           ctx.font = "bold 10px system-ui";
           ctx.textAlign = "center";
           ctx.fillText("BOMB", x + CELL/2, y + CELL/2 + 5);
           
           // Draw lifetime indicator
           ctx.fillStyle = "#ff0000";
           ctx.font = "bold 12px system-ui";
           ctx.fillText(`${lifetime}`, x + CELL/2, y + CELL/2 + 20);
         } else if(isBonusPiece(r, c)) {
           // Draw bonus piece with multiplier
           let piece = getBonusPiece(r, c);
           let multiplier = piece.multiplier;
           
           console.log(`Drawing bonus piece x${multiplier} at (${r}, ${c}) with color ${piece.color}`);
           
           ctx.fillStyle = piece.color;
           ctx.fillRect(x+2,y+2,CELL-4,CELL-4);
           ctx.strokeStyle = "#ffffff";
           ctx.lineWidth = 2;
           ctx.strokeRect(x+2, y+2, CELL-4, CELL-4);
           
           // Draw multiplier (x2, x3, etc.)
           ctx.fillStyle = "#ffffff";
           ctx.font = "bold 14px system-ui";
           ctx.textAlign = "center";
           ctx.fillText(`x${multiplier}`, x + CELL/2, y + CELL/2 + 5);
           
           // Draw lifetime indicator
           ctx.fillStyle = "#ffffff";
           ctx.font = "10px system-ui";
           ctx.fillText(`${piece.lifetime}`, x + CELL/2, y + CELL/2 + 20);
         } else if(grid[r][c]) {
          // Draw placed piece
          ctx.fillStyle = "#5865f2";
          ctx.fillRect(x+2,y+2,CELL-4,CELL-4);
        } else {
          // Draw empty cell
          ctx.fillStyle = "#1c2342";
          ctx.fillRect(x+2,y+2,CELL-4,CELL-4);
          ctx.strokeStyle = "#2a3156";
          ctx.lineWidth = 1;
          ctx.strokeRect(x+2, y+2, CELL-4, CELL-4);
        }
      }
    }
    
    // header stats
    let FR = getFillRate();
    let multiplier = Math.min(scoring.comboSteps[comboLevel], scoring.comboCap).toFixed(2);
    ctx.fillStyle="#E8EBF7";
    ctx.font="bold 16px system-ui";
    ctx.fillText(`ƒêi·ªÉm: ${score}`, BOARD_X, BOARD_Y-12);
    ctx.fillText(`FR: ${(FR*100).toFixed(0)}%`, BOARD_X+150, BOARD_Y-12);
    ctx.fillText(`Chain √ó${multiplier}`, BOARD_X+250, BOARD_Y-12);
    
    // Game mode indicator
    ctx.fillStyle = "#5de4c7";
    ctx.font = "bold 14px system-ui";
    ctx.fillText(`${getModeDisplayName(currentGameMode)}`, BOARD_X+400, BOARD_Y-12);
    
    // High score indicator
    if(score >= highScore && score > 0) {
      ctx.fillStyle = "#ffd43b";
      ctx.font = "bold 14px system-ui";
      ctx.fillText("üèÜ HIGH SCORE!", BOARD_X+400, BOARD_Y-28);
    }
  }

  function drawPieceAt(piece, px, py, scale=1.0, color=null){
    let size = CELL*scale;
    // compute min bounds to align
    let minr=Infinity, minc=Infinity;
    for(const cell of piece.cells){ if(cell.r<minr) minr=cell.r; if(cell.c<minc) minc=cell.c; }
    
    // Use piece color if available, otherwise use provided color
    let pieceColor = color || piece.color || "#9aa5ff";
    
    for(const cell of piece.cells){
      let x = px + (cell.c - minc)*size;
      let y = py + (cell.r - minr)*size;
      ctx.fillStyle = pieceColor;
      ctx.fillRect(x+3,y+3,size-6,size-6);
      ctx.strokeStyle="#101425"; ctx.lineWidth=2; ctx.strokeRect(x+3,y+3,size-6,size-6);
    }
  }

  function drawPool(){
    let gap = 12, box = 140;
    let totalW = box*3 + gap*2;
    let left = (W-totalW)/2;
    let top = POOL_Y;

    // Draw pool title
    ctx.fillStyle = "#E8EBF7";
    ctx.font = "bold 16px system-ui";
    ctx.fillText("POOL - Ch·ªçn kh·ªëi ƒë·ªÉ ƒë·∫∑t", left, top - 20);
    
    // Debug: Show pool state (hidden)
    // ctx.fillStyle = "#f7768e";
    // ctx.font = "12px system-ui";
    // ctx.fillText(`Debug: Pool has ${pool.filter(p => p !== null).length}/3 pieces`, left, top - 5);
    
    ctx.font="bold 14px system-ui";
    for(let i=0;i<3;i++){
      let x=left+i*(box+gap), y=top;
      
      // Always draw all 3 slots regardless of content
      ctx.strokeStyle = (selected.index===i?"#5de4c7":"#2a3156");
      ctx.lineWidth = 3;
      ctx.strokeRect(x, y, box, box);
      
      // Slot background
      ctx.fillStyle = "rgba(43, 51, 92, 0.3)";
      ctx.fillRect(x+1, y+1, box-2, box-2);

      if(pool[i] !== null){
        // Draw piece
        drawPieceAt(pool[i], x+20, y+20, 0.6, selected.index===i?"#5de4c7":null);
      } else {
        // Show empty slot
        ctx.fillStyle="#2a3156"; 
        ctx.fillRect(x+20, y+20, 100, 100);
        ctx.strokeStyle = "#3a4376";
        ctx.strokeRect(x+20, y+20, 100, 100);
        ctx.fillStyle = "#8b90a7";
        ctx.font = "12px system-ui";
        ctx.fillText("Empty", x+box/2-20, y+box/2+5);
      }
      
      // Slot label
      ctx.fillStyle="#E8EBF7";
      ctx.fillText(`Slot ${i+1}`, x+6, y+16);
      
      // Swap tip - positioned above each slot
      ctx.fillStyle = swapCD>0? "#8b90a7" : "#a6da95";
      ctx.font = "12px system-ui";
      ctx.fillText(`Swap: ph√≠m ${i+1} ${swapCD>0?`(CD ${swapCD})`:""}`, x+box/2-30, y-8);
    }

    // Hold panel - moved to better position
    let hx=40, hy=POOL_Y+160, hw=180, hh=80;
    ctx.strokeStyle="#2a3156"; 
    ctx.lineWidth = 2;
    ctx.strokeRect(hx,hy,hw,hh);
    
    // Hold background
    ctx.fillStyle = "rgba(43, 51, 92, 0.3)";
    ctx.fillRect(hx+1, hy+1, hw-2, hh-2);
    
    ctx.fillStyle="#E8EBF7"; 
    ctx.font = "bold 14px system-ui";
    ctx.fillText("Hold (ph√≠m H)", hx+8, hy+16);
    ctx.fillText(hold.cd>0?`CD: ${hold.cd}`:"", hx+8, hy+34);
    
    if(hold.piece){ 
      drawPieceAt(hold.piece, hx+100, hy+20, 0.45, "#ffd580"); 
    } else {
      // Show empty hold slot
      ctx.fillStyle = "#2a3156";
      ctx.fillRect(hx+100, hy+20, 60, 60);
      ctx.strokeStyle = "#3a4376";
      ctx.strokeRect(hx+100, hy+20, 60, 60);
    }

    // Hint
    ctx.fillStyle="#8b90a7";
    ctx.fillText("Ch·ªçn Slot ‚Üí click √¥ b√†n ƒë·ªÉ ƒë·∫∑t. Chu·ªôt ph·∫£i: b·ªè ch·ªçn.", W-370, POOL_Y+200);
  }

  function render(){
    ctx.clearRect(0,0,W,H);
    
    // Debug: Log pool state before drawing (hidden)
    // console.log('Render - Pool state:', pool);
    // console.log('Render - Pool length:', pool.length);
    // console.log('Render - Pool null count:', pool.filter(p => p === null).length);
    
    drawBoard();
    drawPool();
         drawComboTexts();
     drawBonusTexts();
           // Only draw bomb texts in Blast Mode
      if (currentGameMode === 'blast') {
        drawBombTexts();
      }
     updateStats();

    let FR = getFillRate();
    let fairness = justDead? "C√≥ l∆∞·ª£t k·∫πt g·∫ßn ƒë√¢y" : "·ªîn";
    let ftxt = FR>0.7? "CƒÉng" : (FR<0.3? "R·ªông" : "ƒê·∫πp");
         msg(
       `<h3>üìä Th√¥ng Tin Game</h3>` +
       `Turn <b>${turn}</b> ‚Ä¢ <span class="${FR<0.3?"ok":(FR>0.7?"bad":"warn")}">FR: ${(FR*100).toFixed(0)}% (${ftxt})</span>` +
       ` ‚Ä¢ High Score: <span class="hl">${highScore}</span><br/>` +
       `<span class="legend">Swap: ph√≠m 1/2/3 ‚Ä¢ Hold: ph√≠m H ‚Ä¢ Chu·ªôt ph·∫£i: b·ªè ch·ªçn</span>` +
       `<br/><br/><button onclick="resetGame()" style="background: linear-gradient(145deg, #5de4c7, #4a5386); color: #0f1220; border: none; border-radius: 12px; padding: 12px 24px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">üîÑ Ch∆°i L·∫°i</button>`
     );
    
         // Show game over text if game is over
     if(gameOver) {
       document.getElementById('game-over-overlay').style.display = 'block';
       document.getElementById('final-score').textContent = score;
       document.getElementById('current-mode-display').textContent = getModeDisplayName(currentGameMode);
     } else {
       document.getElementById('game-over-overlay').style.display = 'none';
     }
  }

  function generateBombPiece() {
     // Only spawn if Fill Rate >= 50%
   let FR = getFillRate();
   if (FR < 0.5) {
     console.log(`Bomb spawn failed: FR=${FR.toFixed(2)} (need >=0.5)`);
     return;
   }

   // Don't spawn if already at max (1 bomb at a time)
   if (bombPieces.length >= 1) {
     console.log("Bomb spawn failed: Already at max (1 bomb at a time)");
     return;
   }

  // Find positions on EXISTING pieces (not empty cells) to place bomb on
  let availablePositions = [];
  for(let r = 0; r < BOARD_SIZE; r++) {
    for(let c = 0; c < BOARD_SIZE; c++) {
      // Only spawn on cells that have pieces (grid[r][c] = 1) or durable pieces
      if((grid[r][c] || isDurablePiece(r, c)) && !isBonusPiece(r, c) && !isBombPiece(r, c)) {
        availablePositions.push({r: r, c: c});
      }
    }
  }
  
  if(availablePositions.length === 0) {
    console.log("Bomb spawn failed: No available positions on existing pieces");
    return;
  }

  // Pick random position from available ones
  let posIndex = Math.floor(Math.random() * availablePositions.length);
  let pos = availablePositions[posIndex];
  
  // Random lifetime 1-2 turns
  let lifetime = Math.floor(Math.random() * 2) + 1;

  bombPieces.push({
    r: pos.r,
    c: pos.c,
    lifetime: lifetime,
    color: "#000000" // Black color for bomb to distinguish from durable pieces
  });
  
     console.log(`Bomb spawned at (${pos.r}, ${pos.c}) with ${lifetime} turns lifetime. FR was ${FR.toFixed(2)}`);
}

  function decreaseBombLifetimes() {
    console.log(`Decreasing bomb lifetimes. Before: ${bombPieces.length} pieces`);
    bombPieces.forEach(piece => {
      piece.lifetime--;
      console.log(`Bomb at (${piece.r}, ${piece.c}) lifetime: ${piece.lifetime + 1} -> ${piece.lifetime}`);
    });
    let beforeCount = bombPieces.length;
    bombPieces = bombPieces.filter(piece => piece.lifetime > 0);
    let afterCount = bombPieces.length;
    if(beforeCount !== afterCount) {
      console.log(`Removed ${beforeCount - afterCount} expired bomb pieces. Remaining: ${afterCount}`);
    }
  }

  function explodeBomb(bombR, bombC) {
  console.log(`Bomb exploded at (${bombR}, ${bombC})!`);

  let explosionScore = 0;
  let bonusPiecesActivated = [];

  // Clear all pieces in the 3x3 area around the bomb
  for(let r = bombR - 1; r <= bombR + 1; r++) {
    for(let c = bombC - 1; c <= bombC + 1; c++) {
      if(r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
        if(grid[r][c] || isDurablePiece(r, c) || isBonusPiece(r, c)) {
          // If it's a durable piece, reduce its durability
          let piece = getDurablePiece(r, c);
          if(piece) {
            piece.durability = Math.max(0, piece.durability - 1);
            console.log(`Durable piece at (${r}, ${c}) durability reduced to ${piece.durability}`);
            explosionScore += 1; // Score for hitting durable piece
          }
          
          // If it's a bonus piece, activate it and add to score
          let bonusPiece = getBonusPiece(r, c);
          if(bonusPiece) {
            bonusPiecesActivated.push(bonusPiece);
            explosionScore += bonusPiece.multiplier; // Score for bonus piece
            console.log(`Bonus piece x${bonusPiece.multiplier} at (${r}, ${c}) activated by explosion!`);
          }
          
          // Clear the cell
          grid[r][c] = 0;
          explosionScore += 1; // Score for clearing regular piece
          console.log(`Cell at (${r}, ${c}) cleared.`);
        }
      }
    }
  }

  // Remove pieces with 0 durability
  durablePieces = durablePieces.filter(piece => piece.durability > 0);
  
  // Remove activated bonus pieces
  bonusPieces = bonusPieces.filter(piece => 
    !bonusPiecesActivated.some(activated => activated.r === piece.r && activated.c === piece.c)
  );

  // Add explosion score text
  let centerX = BOARD_X + (BOARD_SIZE * CELL) / 2;
  let centerY = BOARD_Y + (BOARD_SIZE * CELL) / 2;
  addBombText(`üí• BOOM! +${explosionScore}`, centerX, centerY + 120);

  // Add score for explosion
  score += explosionScore;
  
  // Remove the bomb piece that exploded
  bombPieces = bombPieces.filter(bomb => !(bomb.r === bombR && bomb.c === bombC));
  console.log(`Bomb exploded, score added: +${explosionScore}, bomb pieces remaining: ${bombPieces.length}`);
}

  // Event Listeners for Game Mode System
  document.addEventListener('DOMContentLoaded', function() {
    // Mode selector buttons
    document.querySelectorAll('.mode-button[data-mode]').forEach(button => {
      button.addEventListener('click', function() {
        const mode = this.getAttribute('data-mode');
        selectGameMode(mode);
      });
    });
    
    // Other mode buttons in game over screen
    document.querySelectorAll('.other-mode-btn').forEach(button => {
      button.addEventListener('click', function() {
        const mode = this.getAttribute('data-mode');
        selectGameMode(mode);
      });
    });
    
    // Initialize high score display
    updateHighScoreDisplay();
  });
  
  // Boot
  if (currentGameMode === 'blocker') {
    generateDurablePieces();
  }
  
  // Ensure pool starts with 3 pieces
  pool = [null, null, null];
  
  refillPool();
  
  // Double check pool has 3 pieces
  if(pool.some(p => p === null)) {
    refillPool();
  }

  render();
})();
</script>
</body>
</html>
